{"[\"leetcode\", \"easy\"]": [{"path": "leetcode_easy_isPalindrome.md", "topic": "[\"leetcode\", \"easy\"]", "title": "判断一个整数是否是回文数", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/isPalindrome.md", "body": "```go\n//回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n//\n// 示例 1:\n//\n// 输入: 121\n//输出: true\n//\n//\n// 示例 2:\n//\n// 输入: -121\n//输出: false\n//解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n//\n//\n// 示例 3:\n//\n// 输入: 10\n//输出: false\n//解释: 从右向左读, 为 01 。因此它不是一个回文数。\n//\n//\n// 进阶:\n//\n// 你能不将整数转为字符串来解决这个问题吗？\n// Related Topics 数学\n// 👍 1137 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\n\npackage main\n\nimport \"strconv\"\n\nfunc isPalindrome(x int) bool {\n\tback := 0\n\tbegin := x\n\tfor {\n\t\tif x < 0 {\n\t\t\treturn false\n\t\t}\n\n\t\tif x == 0 {\n\t\t\treturn back == begin\n\t\t}\n\n\t\tback = back*10 + x%10\n\t\tx = x / 10\n\t}\n\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n\nfunc isPalindrome2(x int) bool {\n\n\tbegin := strconv.Itoa(x)\n\trunes := []rune(begin)\n\tfor from, to := 0, len(begin)-1; from < to; from, to = from+1, to-1 {\n\t\trunes[from], runes[to] = runes[to], runes[from]\n\t}\n\n\treturn begin == string(runes)\n\t//var end = \"\"\n\t//for i := len(begin) -1;i >=0 ;i--  {\n\t//\tend  = end + string(begin[i])\n\t//}\n}\nfunc main() {\n\tpalindrome := isPalindrome2(112211)\n\tprint(palindrome)\n}\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_mergeTwoLists.md", "topic": "[\"leetcode\", \"easy\"]", "title": "将两个升序链表合并为一个新的 升序 链表并返回", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/mergeTwoLists.md", "body": "```go\n\npackage main\n\n//将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n//\n//\n//\n// 示例：\n//\n// 输入：1->2->4, 1->3->4\n//输出：1->1->2->3->4->4\n//\n// Related Topics 链表\n// 👍 1143 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\n/**\n* Definition for singly-linked list.\n */\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc mergeTwoLists3(l1 *ListNode, l2 *ListNode) *ListNode {\n\tvar head = &ListNode{}\n\ttail := head\n\tfor l1 != nil && l2 != nil {\n\t\tif l1.Val > l2.Val {\n\t\t\ttail.Next = l2\n\t\t\tl2 = l2.Next\n\t\t} else {\n\t\t\ttail.Next = l1\n\t\t\tl1 = l1.Next\n\t\t}\n\t\ttail = tail.Next\n\t}\n\tif l1 != nil {\n\t\ttail.Next = l1\n\t} else {\n\t\ttail.Next = l2\n\t}\n\treturn head.Next\n}\n\nfunc mergeTwoLists4(l1 *ListNode, l2 *ListNode) *ListNode {\n\tif l1 == nil {\n\t\treturn l2\n\t}\n\tif l2 == nil {\n\t\treturn l1\n\t}\n\n\tif l1.Val > l2.Val {\n\t\tl2.Next = mergeTwoLists4(l1, l2.Next)\n\t\treturn l2\n\t} else {\n\t\tl1.Next = mergeTwoLists4(l1.Next, l2)\n\t\treturn l1\n\t}\n\n}\n\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {\n\tvar dump = &ListNode{}\n\tpre := dump\n\t//迭代\n\tfor l1 != nil && l2 != nil {\n\t\tif l1.Val < l2.Val {\n\t\t\tpre.Next = l1\n\t\t\tl1 = l1.Next\n\t\t} else {\n\t\t\tpre.Next = l2\n\t\t\tl2 = l2.Next\n\t\t}\n\t\tpre = pre.Next\n\t}\n\tif l1 != nil {\n\t\tpre.Next = l1\n\t} else {\n\t\tpre.Next = l2\n\t}\n\treturn dump.Next\n}\nfunc mergeTwoLists2(l1 *ListNode, l2 *ListNode) *ListNode {\n\t//递归\n\tif l1 == nil {\n\t\treturn l2\n\t}\n\tif l2 == nil {\n\t\treturn l1\n\t}\n\tif l1.Val < l2.Val {\n\t\tl1.Next = mergeTwoLists2(l1.Next, l2)\n\t\treturn l1\n\t} else {\n\t\tl2.Next = mergeTwoLists2(l1, l2.Next)\n\t\treturn l2\n\t}\n\n}\n\nfunc main() {\n\tvar l1 = new(ListNode)\n\tvar l11 = new(ListNode)\n\tvar l111 = new(ListNode)\n\tvar l2 = new(ListNode)\n\tvar l21 = new(ListNode)\n\tvar l211 = new(ListNode)\n\tl1.Val = 1\n\tl11.Val = 2\n\tl111.Val = 4\n\tl1.Next = l11\n\tl11.Next = l111\n\tl2.Val = 1\n\tl21.Val = 3\n\tl211.Val = 4\n\tl2.Next = l21\n\tl21.Next = l211\n\n\tlists := mergeTwoLists4(l1, l2)\n\tfor lists.Next != nil {\n\n\t\tprint(lists.Val)\n\t\tlists = lists.Next\n\t}\n\tprint(lists.Val)\n\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_searchInsert.md", "topic": "[\"leetcode\", \"easy\"]", "title": "搜索插入位置", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/searchInsert.md", "body": "```go \npackage main\n\n//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n//\n// 你可以假设数组中无重复元素。\n//\n// 示例 1:\n//\n// 输入: [1,3,5,6], 5\n//输出: 2\n//\n//\n// 示例 2:\n//\n// 输入: [1,3,5,6], 2\n//输出: 1\n//\n//\n// 示例 3:\n//\n// 输入: [1,3,5,6], 7\n//输出: 4\n//\n//\n// 示例 4:\n//\n// 输入: [1,3,5,6], 0\n//输出: 0\n//\n// Related Topics 数组 二分查找\n// 👍 611 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc searchInsert(nums []int, target int) int {\n\tvar middle int\n\tfor from, end := 0, len(nums)-1; ; {\n\n\t\tmiddle = from + ((end - from) / 2)\n\n\t\tif nums[middle] > target {\n\t\t\tif middle-1 < 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif nums[middle-1] < target {\n\t\t\t\treturn middle\n\t\t\t} else if nums[middle-1] == target {\n\t\t\t\treturn middle - 1\n\t\t\t}\n\t\t\tend = middle - 1\n\t\t} else if nums[middle] < target {\n\t\t\tif middle+1 >= len(nums) {\n\t\t\t\treturn len(nums)\n\t\t\t}\n\t\t\tif nums[middle+1] >= target {\n\t\t\t\treturn middle + 1\n\t\t\t}\n\t\t\tfrom = middle + 1\n\t\t} else {\n\t\t\treturn middle\n\t\t}\n\t}\n\n}\nfunc main() {\n\tvar num = []int{123}\n\tinsert := searchInsert(num, 1309)\n\tprint(insert)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_romanToInt.md", "topic": "[\"leetcode\", \"easy\"]", "title": "罗马数字", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/romanToInt.md", "body": "```go\npackage main\n\n//罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n//\n// 字符          数值\n//I             1\n//V             5\n//X             10\n//L             50\n//C             100\n//D             500\n//M             1000\n//\n// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + I\n//I 。\n//\n// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5\n// 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n//\n//\n// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\n// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n//\n//\n// 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n//\n// 示例 1:\n//\n// 输入: \"III\"\n//输出: 3\n//\n// 示例 2:\n//\n// 输入: \"IV\"\n//输出: 4\n//\n// 示例 3:\n//\n// 输入: \"IX\"\n//输出: 9\n//\n// 示例 4:\n//\n// 输入: \"LVIII\"\n//输出: 58\n//解释: L = 50, V= 5, III = 3.\n//\n//\n// 示例 5:\n//\n// 输入: \"MCMXCIV\"\n//输出: 1994\n//解释: M = 1000, CM = 900, XC = 90, IV = 4.\n// Related Topics 数学 字符串\n// 👍 948 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\n\nfunc romanToInt(s string) int {\n\tvar end int\n\tsmap := map[string]int{\n\t\t\"I\":  1,\n\t\t\"V\":  5,\n\t\t\"X\":  10,\n\t\t\"L\":  50,\n\t\t\"C\":  100,\n\t\t\"D\":  500,\n\t\t\"M\":  1000,\n\t\t\"IV\": 4,\n\t\t\"IX\": 9,\n\t\t\"XL\": 40,\n\t\t\"XC\": 90,\n\t\t\"CD\": 400,\n\t\t\"CM\": 900,\n\t}\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif i+1 < len(s) && smap[string(s[i])+string(s[i+1])] > 0 {\n\t\t\tend = end + smap[string(s[i])+string(s[i+1])]\n\t\t\ti++\n\t\t} else {\n\t\t\tend = end + smap[string(s[i])]\n\t\t}\n\t}\n\n\treturn end\n\n}\nfunc main() {\n\ti := romanToInt(\"LVIII\")\n\tprint(i)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_strStr.md", "topic": "[\"leetcode\", \"easy\"]", "title": "实现 strStr() 函数。", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/strStr.md", "body": "```go\npackage main\n\n//实现 strStr() 函数。\n//\n// 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如\n//果不存在，则返回 -1。\n//\n// 示例 1:\n//\n// 输入: haystack = \"hello\", needle = \"ll\"\n//输出: 2\n//\n//\n// 示例 2:\n//\n// 输入: haystack = \"aaaaa\", needle = \"bba\"\n//输出: -1\n//\n//\n// 说明:\n//\n// 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n//\n// 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n// Related Topics 双指针 字符串\n// 👍 502 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc strStr(haystack string, needle string) int {\n\tif len(needle) == 0 {\n\t\treturn 0\n\t}\n\tif len(haystack) == 0 {\n\t\treturn -1\n\t}\n\n\t//return  strings.Index(haystack, needle)\n\n\t// kmp算法实现\n\t//kmp()\n\treturn -1\n}\n\nfunc kmp(haystack string, needle string) int {\n\t//hay := []rune(haystack)\n\t//need := []rune(needle)\n\t//lh := len(hay)\n\t//ln := len(need)\n\n\treturn 0\n}\n\nfunc get_next(needle []rune) map[int]int {\n\tvar returns = make(map[int]int)\n\n\tvar length = len(needle)\n\tbegin := 0\n\thit := -1\n\tfor begin < length {\n\t\tif hit == -1 || needle[hit] == needle[begin] {\n\t\t\thit++\n\t\t\tbegin++\n\t\t\tif needle[begin] != needle[hit] {\n\t\t\t\treturns[begin] = hit\n\t\t\t} else {\n\t\t\t\treturns[begin] = returns[hit]\n\t\t\t}\n\t\t} else {\n\t\t\thit = returns[hit]\n\t\t}\n\n\t}\n\n\treturn returns\n}\n\nfunc main() {\n\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_countAndSay.md", "topic": "[\"leetcode\", \"easy\"]", "title": "外观数列", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/countAndSay.md", "body": "```go\n// 注意：整数序列中的每一项将表示为一个字符串。\n//\n// 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：\n//\n//1.     1\n//2.     11\n//3.     21\n//4.     1211\n//5.     111221\n//\n//\n// 第一项是数字 1\n//\n// 描述前一项，这个数是 1 即 “一个 1 ”，记作 11\n//\n// 描述前一项，这个数是 11 即 “两个 1 ” ，记作 21\n//\n// 描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211\n//\n// 描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221\n//\n//\n//\n// 示例 1:\n//\n// 输入: 1\n//输出: \"1\"\n//解释：这是一个基本样例。\n//\n// 示例 2:\n//\n// 输入: 4\n//输出: \"1211\"\n//解释：当 n = 3 时，序列是 \"21\"，其中我们有 \"2\" 和 \"1\" 两组，\"2\" 可以读作 \"12\"，也就是出现频次 = 1 而 值 = 2；类似\n//\"1\" 可以读作 \"11\"。所以答案是 \"12\" 和 \"11\" 组合在一起，也就是 \"1211\"。\n// Related Topics 字符串\n// 👍 503 👎 0\n\n\npackage main\n\nimport \"strconv\"\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc countAndSay(n int) string {\n\t//迭代\n\tback := \"1\"\n\tchange := 1\n\tvar count []int\n\tfor i := 1; i <= n; i++ {\n\t\tfor times, loop := 1, 0; loop < len(back); loop++ {\n\t\t\tif int(back[loop]) == change {\n\t\t\t\ttimes++\n\t\t\t} else {\n\t\t\t\tcount = append(count,times,change)\n\t\t\t\tchange++\n\t\t\t}\n\t\t}\n\n\t\tfor e := range count {\n\t\t\tback = strconv.Itoa(count[e])\n\t\t}\n\t}\n\treturn back\n}\nfunc main() {\n\t//say := countAndSay(2)\n\t//print(say)\n\tvar back string\n\tvar count = []int{1, 2, 34, 5}\n\tfor e := range count {\n\t\tback = back + strconv.Itoa(count[e])\n\t}\n\tprint(back)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_reverse.md", "topic": "[\"leetcode\", \"easy\"]", "title": "给出一个 32 位的有符号整数,将这个整数中每位上的数字进行反转", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/reverse.md", "body": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n//给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n//\n//示例 1:\n//\n//输入: 123\n//输出: 321\n//\n//\n//示例 2:\n//\n//输入: -123\n//输出: -321\n//\n//\n//示例 3:\n//\n//输入: 120\n//输出: 21\n//\n//\n//注意:\n//\n// 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n// Related Topics 数学\n// 👍 1997 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\n\nfunc reverse(x int) int {\n\tvar back int32 = 0\n\tfor {\n\n\t\tif x == 0 {\n\t\t\treturn int(back)\n\t\t}\n\n\t\tif (back*10)/10 != back {\n\t\t\treturn 0\n\t\t}\n\n\t\tback = back*10 + int32(x%10)\n\n\t\tx = x / 10\n\t}\n\n}\n\nfunc main() {\n\ti := reverse(-2147483412)\n\tfmt.Print(i)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_longestCommonPrefix.md", "topic": "[\"leetcode\", \"easy\"]", "title": "编写一个函数来查找字符串数组中的最长公共前缀。", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/longestCommonPrefix.md", "body": "```go\npackage main\n\n//编写一个函数来查找字符串数组中的最长公共前缀。\n//\n// 如果不存在公共前缀，返回空字符串 \"\"。\n//\n// 示例 1:\n//\n// 输入: [\"flower\",\"flow\",\"flight\"]\n//输出: \"fl\"\n//\n//\n// 示例 2:\n//\n// 输入: [\"dog\",\"racecar\",\"car\"]\n//输出: \"\"\n//解释: 输入不存在公共前缀。\n//\n//\n// 说明:\n//\n// 所有输入只包含小写字母 a-z 。\n// Related Topics 字符串\n// 👍 1138 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc longestCommonPrefix(strs []string) string {\n\n\tvar nums []string\n\tvar checked = -1\n\n\tif len(strs) > 0 {\n\n\t\tfor i := 0; i < len(strs[0]); i++ {\n\t\t\tnums = append(nums, string(strs[0][i]))\n\t\t}\n\t\tchecked = len(nums) - 1\n\n\t\tfor i := 1; i < len(strs); i++ {\n\t\t\tcc := -1\n\t\t\tfor j := 0; j < len(strs[i]) && j <= checked; j++ {\n\t\t\t\tif string(strs[i][j]) == nums[j] {\n\t\t\t\t\tcc = j\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif checked > cc {\n\t\t\t\tchecked = cc\n\t\t\t}\n\t\t}\n\t}\n\treturns := \"\"\n\tif checked == -1 {\n\t\treturn returns\n\t}\n\tfor i := 0; i <= checked; i++ {\n\t\treturns += nums[i]\n\t}\n\treturn returns\n\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\nfunc main() {\n\tvar strs = []string{\"aca\", \"cba\"}\n\tprefix := longestCommonPrefix(strs)\n\tprint(prefix)\n}\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_removeDuplicates.md", "topic": "[\"leetcode\", \"easy\"]", "title": "给定一个排序数组，需要在原地删除重复出现的元素", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/removeDuplicates.md", "body": "```go\npackage main\n\n// 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n//\n// 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n//\n//\n//\n// 示例 1:\n//\n// 给定数组 nums = [1,1,2],\n//\n//函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n//\n//你不需要考虑数组中超出新长度后面的元素。\n//\n// 示例 2:\n//\n// 给定 nums = [0,0,1,1,1,2,2,3,3,4],\n//\n// 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n//\n// 你不需要考虑数组中超出新长度后面的元素。\n//\n//\n//\n//\n// 说明:\n//\n// 为什么返回数值是整数，但输出的答案是数组呢?\n//\n// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n//\n// 你可以想象内部操作如下:\n//\n// // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\n//int len = removeDuplicates(nums);\n//\n//// 在函数里修改输入数组对于调用者是可见的。\n//// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\n//for (int i = 0; i < len; i++) {\n//    print(nums[i]);\n//}\n//\n// Related Topics 数组 双指针\n// 👍 1526 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\n\nfunc removeDuplicates(nums []int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\n\tfor i := 0; i < len(nums); i++ {\n\t\tfor j := i; j < len(nums)-i; j++ {\n\t\t\tif nums[i] > nums[j] {\n\t\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t\t}\n\t\t}\n\t}\n\n\tindex := nums[0]\n\tcurrent := 1\n\tfor i := 1; i < len(nums); i++ {\n\t\tif index != nums[i] {\n\t\t\tindex = nums[i]\n\t\t\tnums[current] = index\n\t\t\tcurrent++\n\t\t}\n\t}\n\tfor e := range nums[:current] {\n\t\tprint(nums[e])\n\t}\n\treturn len(nums[:current])\n}\n\nfunc main() {\n\tnum := []int{1, 2, 0, 1, 2, 3, 4}\n\tprint(removeDuplicates(num))\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_removeElement.md", "topic": "[\"leetcode\", \"easy\"]", "title": "移除所有数值等于val的元素", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/removeElement.md", "body": "```go\n\npackage main\n\n//给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n//\n// 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n//\n// 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n//\n//\n//\n// 示例 1:\n//\n// 给定 nums = [3,2,2,3], val = 3,\n//\n//函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n//\n//你不需要考虑数组中超出新长度后面的元素。\n//\n//\n// 示例 2:\n//\n// 给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n//\n//函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n//\n//注意这五个元素可为任意顺序。\n//\n//你不需要考虑数组中超出新长度后面的元素。\n//\n//\n//\n//\n// 说明:\n//\n// 为什么返回数值是整数，但输出的答案是数组呢?\n//\n// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n//\n// 你可以想象内部操作如下:\n//\n// // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n//int len = removeElement(nums, val);\n//\n//// 在函数里修改输入数组对于调用者是可见的。\n//// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n//for (int i = 0; i < len; i++) {\n//    print(nums[i]);\n//}\n//\n// Related Topics 数组 双指针\n// 👍 592 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc removeElement(nums []int, val int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\n\tattack := 0\n\tfor i := 0; i < len(nums)-1; i++ {\n\t\tif val != nums[i] {\n\t\t\tnums[attack] = nums[i]\n\t\t\tattack++\n\t\t}\n\t}\n\treturn len(nums[:attack])\n}\nfunc main() {\n\tnum := []int{1, 2, 0, 1, 2, 3, 4}\n\tprint(removeElement(num, 1))\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_twoSum.md", "topic": "[\"leetcode\", \"easy\"]", "title": "两数之合", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/twoSum.md", "body": "```go\npackage main\n\nimport \"fmt\"\n\n//给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n//\n// 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n//\n//\n//\n// 示例:\n//\n// 给定 nums = [2, 7, 11, 15], target = 9\n//\n//因为 nums[0] + nums[1] = 2 + 7 = 9\n//所以返回 [0, 1]\n//\n// Related Topics 数组 哈希表\n// 👍 8589 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc twoSum(nums []int, target int) []int {\n\tvar names []int\n\tfor i := 0; i < len(nums); i++ {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif nums[i]+nums[j] == target {\n\t\t\t\treturn append(names, i, j)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tvar names = []int{1, 2, 3, 4, 5, 7}\n\tvar sum = twoSum(names, 8)\n\tfmt.Printf(\"输出结果为 %d\", sum)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_isValid.md", "topic": "[\"leetcode\", \"easy\"]", "title": "判断字符串是否有效", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/isValid.md", "body": "```go\npackage main\n\n\nimport (\n\t\"strings\"\n)\n\n//给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n//\n// 有效字符串需满足：\n//\n//\n// 左括号必须用相同类型的右括号闭合。\n// 左括号必须以正确的顺序闭合。\n//\n//\n// 注意空字符串可被认为是有效字符串。\n//\n// 示例 1:\n//\n// 输入: \"()\"\n//输出: true\n//\n//\n// 示例 2:\n//\n// 输入: \"()[]{}\"\n//输出: true\n//\n//\n// 示例 3:\n//\n// 输入: \"(]\"\n//输出: false\n//\n//\n// 示例 4:\n//\n// 输入: \"([)]\"\n//输出: false\n//\n//\n// 示例 5:\n//\n// 输入: \"{[]}\"\n//输出: true\n// Related Topics 栈 字符串\n// 👍 1673 👎 0\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc isValid(s string) bool {\n\tsum := float64(rune(s[0]))\n\tfor i := 0; i < len(s)-1; i++ {\n\t\ta := float64(rune(s[i]))\n\t\tb := float64(rune(s[i+1]))\n\t\tif a-b < 0 && a-b >= -2 {\n\t\t\tsum = sum - a - b\n\t\t} else if a-b > 0 {\n\t\t\tsum = sum - a + b\n\t\t} else {\n\t\t\tsum = sum + a + b\n\t\t}\n\t}\n\n\treturn sum <= float64(len(s)) && sum >= -float64(len(s))\n}\n\nfunc isValid2(s string) bool {\n\tbrackets := []string{\"{}\", \"()\", \"[]\"}\n\tif s == \"\" {\n\t\treturn true\n\t}\n\tif len(s)%2 != 0 {\n\t\treturn false\n\t}\n\ttimes := len(s) / 2\n\tfor i := 0; i < times; i++ {\n\t\tfor _, v := range brackets {\n\t\t\tfor strings.Contains(s, v) {\n\t\t\t\ts = strings.ReplaceAll(s, v, \"\")\n\t\t\t}\n\t\t}\n\t\tif s == \"\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tvalid := isValid2(\"(())\")\n\tprint(valid)\n}\n\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-28T10:56:06+08:00", "created_utc": "2020-07-28T02:56:06+00:00", "updated": "2020-07-28T17:45:07+08:00", "updated_utc": "2020-07-28T09:45:07+00:00"}, {"path": "leetcode_easy_maxSubarray.md", "topic": "[\"leetcode\", \"easy\"]", "title": "maxSubArray-最大子序和", "url": "https://github.com/fulln/TIL/blob/master/leetcode/easy/maxSubarray.md", "body": "```go\n//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 \n//\n// 示例: \n//\n// 输入: [-2,1,-3,4,-1,2,1,-5,4]\n//输出: 6\n//解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n// \n//\n// 进阶: \n//\n// 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 \n// Related Topics 数组 分治算法 动态规划 \n// 👍 2239 👎 0\n\n\n//leetcode submit region begin(Prohibit modification and deletion)\nfunc maxSubArray(nums []int) int {\n\tvar maxSum = nums[0]\n\tvar sum int\n\tfor i := range nums {\n\t\tif sum > 0{\n\t\t\tsum += nums[i]\n\t\t}else {\n\t\t\tsum = nums[i]\n\t\t}\n\n\t\tif maxSum < sum {\n\t\t\tmaxSum = sum\n\t\t}\n\t}\n\n\n\treturn maxSum\n}\n//leetcode submit region end(Prohibit modification and deletion)\n```", "created": "2020-07-29T23:52:35+08:00", "created_utc": "2020-07-29T15:52:35+00:00", "updated": "2020-07-30T11:13:29+08:00", "updated_utc": "2020-07-30T03:13:29+00:00"}], "[\"vim\"]": [{"path": "vim_vim_plugins_fzf.md", "topic": "[\"vim\"]", "title": "vim 安装fzf", "url": "https://github.com/fulln/TIL/blob/master/vim/vim_plugins_fzf.md", "body": "### 简介\nFuzzy finder 是一款使用 GO 语言编写的交互式的 Unix 命令行工具。可以用来查找任何 列表 内容，文件、Git 分支、进程等。所有的命令行工具可以生成列表输出的都可以再通过管道 pipe 到 fzf 上进行搜索和查找\n\n### 安装\n\n在macos下 \n```\nbrew install fzf\n```\n\n### 安装插件\n\n如果你本地安装过 fzf 命令行工具了，只需要在 .vimrc 里面添加下面两个插件配置即可\n\n```\nPlug '/usr/local/opt/fzf'\nPlug 'junegunn/fzf.vim'\n```\n\n### 自定义插件配置\n\n我是参考的[这个](https://github.com/wsgggws/my-neovim-configurations)的配置\n\n```\n\" ------------------------------------------------\n\"  For fzf.vim\n\" ------------------------------------------------\n\"<Leader>f在当前目录搜索文件\nnnoremap <silent> <Leader>f :Files<CR>\nnnoremap <silent> <C-p> :Files<CR>\n\"<Leader>b切换Buffer中的文件\nnnoremap <silent> <Leader>b :Buffers<CR>\nnnoremap <silent> <Leader>rg :Rg<CR>\n\"<Leader>p在当前所有加载的Buffer中搜索包含目标词的所有行，:BLines只在当前Buffer中搜索\nnnoremap <silent> <Leader>l :BLines<CR>\n\"<Leader>h在Vim打开的历史文件中搜索，相当于是在MRU中搜索，:History：命令历史查找\nnnoremap <silent> <Leader>h :History<CR>\n\"调用Rg进行搜索，包含隐藏文件\ncommand! -bang -nargs=* Rg\n  \\ call fzf#vim#grep(\n  \\   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,\n  \\   fzf#vim#with_preview(), <bang>0)\nlet g:fzf_preview_window = 'right:50%'\n\"\n```\n> 注意,如果使用rb  先用'brew install rb'进行安装", "created": "2020-07-28T16:54:53+08:00", "created_utc": "2020-07-28T08:54:53+00:00", "updated": "2020-07-28T16:54:53+08:00", "updated_utc": "2020-07-28T08:54:53+00:00"}]}