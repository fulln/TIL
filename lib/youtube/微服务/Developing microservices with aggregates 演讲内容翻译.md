(00:10) 所以，欢迎来到我关于微服务和领域驱动设计的演讲，特别是聚合，目的是真正展示聚合的概念是如何在你使用微服务架构构建业务逻辑或业务应用程序时超级有用的，事实证明，领域驱动设计对微服务的适用性比我所谈论的要广泛得多，还有其他的概念，有点超出了这个演讲的范围，比如有边界的背景和各种战略的概念。

(00:49)DDD的设计概念，但在这次演讲中，我只是专注于聚合的概念，所以在我进入这个话题之前，先介绍一下我，如果你不认识我，我叫Chris Richardson，实际上我住在加州奥克兰，早在80年代中期就开始编程，建立Lisp系统，所以编译器，从运行时间编译器垃圾收集器，一直到IDEs，我最终用Java编程，然后你知道十年前我的书pojos in

(01:29)行动出来了，那都是关于spring和hibernate的，十年前，这些技术绝对是企业Java开发的革命，十年后，你知道spring仍然在创新，仍然非常有意义，所以我对此超级兴奋，然后回到2006年到2007年，我开始玩一个当时非常不起眼的服务，称为亚马逊ec2，我想这是在云计算这个词被开发之前，亚马逊的一个传教士来了，他说

(02:14)在我当地的壶上发言，我们以为他们会讨论买书的api，因为那是亚马逊十年前的名声，但结果却是提供服务器的api，你可以这样做的概念让我大吃一惊，所以我创建了一个开源项目，后来演变成一家名为Cloud Foundry的创业公司，这个名字今天已经有点出名了，有不同的技术，所以我的Cloud Foundry的经典版本是在AWS上部署java应用程序的通道。

(02:48)被spring sauce收购，spring sauce后来被vmware收购，最后在vmware和pivotal工作了若干年，最后几乎离开，所以我想现在是三年前，所以从那时起，我一直专注于微服务这个领域，所以我和Mike refer一起做关于微服务的咨询和培训，我也是一个初创公司的创始人，我们正在建立一个平台，简化使用微服务的商业应用程序的开发，事实上我将要提出的一些概念

(03:24)今天要介绍的内容是由我们的产品支持的，如果你想了解更多关于一般的微服务，那么就去这个链接，学习微服务点IO，在那里你会发现博客文章的链接，文章介绍视频示例代码，这些都是我多年来创造的，所以是一个可以去的地方，这是我的排序，所以这里是议程，所以首先我想谈谈，通过描述你会遇到的各种问题，为其余谈话提供动力。

> [!START] 开始

(04:03)你正在使用领域模型模式实现业务逻辑，以及在微服务架构中的内容，然后我将谈论所有关于聚合的问题，以及它们如何解决这些问题，所以让我们开始吧，首先是关于微服务，你知道今天每个人都在谈论它们，所以我只是要非常非常简单地触及它们，只是说，首先微服务架构的目标是解决大型应用程序的复杂性。

(04:38)耐心，当然，它的方法是使用古老的模块化技术，所以换句话说，它把本来是一个大型的单体应用程序，分解成一组较小的应用程序，以服务的名义，它真的只是一种模块化的形式，每一个微观服务对应一个业务能力，这是一个企业为了创造价值而做的事情，所以如果你把这种思维应用于一个在线商店，你最终会得到一个架构，看起来

(05:16) 就像这样，你有各种服务，对应不同的业务能力，比如维护产品目录信息的目录服务，跟踪评论的评论服务，负责处理订单的订单服务等等，所以我们只是把应用分解成这些微型应用，每个服务都有自己的数据库，这是绝对必要的，以确保松散耦合，但在同时，这是一个

(05:53)双刃剑，因为这将导致许多问题的最终原因，这也是本演讲的动机，所以请记住，每个服务都有自己的数据库，然后当然坐在服务的前面，你将有一个api网关，作为一个门面，提供一个进入微型服务系统的单一入口点，并可能为每个特定类型的客户端提供专用的API，然后你有各种客户端，是

(06:26) 消费这些微型服务可以是一个网络应用程序，也可以是一个移动应用程序，这些服务中的每一个都可以独立扩展，但这有点超出了我们的讨论范围，所以服务强制执行模块化，因为它们有一个非常明确的边界，所以服务是一个进程，最终，一个进程内的一切都属于该进程的私有财产，除非它已经明确地通过API暴露，无论是休息还是消息传递，所以它只是一个非常非常强大的形式。

(07:06) 模块化是在编程语言中很难实现的，就像Java包并不适合构建真正的模块化系统，OSGi试图做到这一点，但我想我们都知道它的成功率有多高，除了你和应用程序开发人员之间的关系，所以这是个微服务架构，所以它使你能够更快地开发和构建更多的模块化应用程序，质量更高，速度更快等，但Micra服务有一整套的挑战。

(07:44)架构，在这次谈话中，我只是要专注于一些非常狭窄的具体问题，如果这些问题影响到你如何实现你的业务逻辑，那么你要遇到的第一个问题是，你的典型领域模型，因为每个人都知道，如果你正在构建复杂的业务逻辑，你应该应用领域模型模式，构建具有丰富结构和丰富行为的对象，你遇到的问题是一个典型的领域模型实际上只是一个类的纠结网，在一个

(08:21)单体应用本身就有问题，但在微服务架构中也有一些真正的问题，因为最终你希望能够把不同的类放在不同的微服务中，但对象是相互指向的，所以订单会有一个对其客户的引用，订单行项目有一个对相应产品的引用，所以当你想把订单对象放在订单服务中，它将有订单对象本身将

(08:54)有一个指向客户的指针，当它跨越服务边界时，这意味着什么呢？这与从订单行项目到产品的打印不一样，所以这是一个问题，一个典型的领域模型不容易被分割到多个服务中去。

(09:36) 信用额度，所以当你放置一个新的水时，你必须验证新的订单不会超过信用额度，在一个单一的应用程序中，这是微不足道的，你开始一个交易，你找到现有的订单，你找到该客户的信用额度，你确保你没有超过信用额度，你可能已经在这一点上买了，然后你插入一个订单，然后你提交交易，假设你使用正确的隔离级别，可序列化。

(10:11)酸交易的属性将强制执行该业务规则，即使有多个同时进行的交易试图为同一个客户创建水域，交易管理器将在本质上将这些交易序列化，所以它们看起来是一个接一个地发生的，所以这是一个非常好的简单编程模型，你知道我们只是习惯于它，有很大的权力，但你有这个方法的问题是，首先它违反了封装，记住每个

(10:52)服务有自己的数据库，所以订单表属于订单服务，客户表属于客户服务，所以你不能在同一个事务中访问它们，你违反了每个服务的封装，所以这是一个问题，另一个问题是，这个事务实际上会跨越多个服务，这当然需要某种形式的分布式事务机制或两件式你知道或两阶段提交机制，事实证明，在现代应用中

(11:32)到PC不是一个可行的选择，一方面，它确实给你提供了某种一致性的保证，尽管你实际上必须阅读小字，看看它给你提供了什么样的隔离级别，但是因为它伴随着一大堆的复杂性和问题，在现代应用中通常最好避免，它不被许多现代技术所支持，如无序数据库或或现代消息经纪人，所以即使你想使用它，你也不能使用，然后还有上限定理，基本上说你

(12:10)有一致性、可用性和分区，你必须选择其中的两个，而今天更倾向于选择可用性而不是一致性，所以在现代应用中使用两阶段提交有某种理论上的问题，所以我们有一个问题，就是这种交易模型不适合我们今天所建立的各种技术和系统，所以这是一个问题，然后特别是它不适合大多数

(12:42)没有续集的数据库往往有一个非常非常有限的交易模型，基本上你可以更新一条记录，不管是文件还是行还是键值垫，在一个典型的没有续集的数据库中，你没有完整的资产交易语义，所以有一种问题，我们用传统的方式来构建应用程序，或者准确地说，我们用它来编写业务逻辑，并将其转化为现代的微服务和续集数据库的世界，所以，是的，这就是

(13:21)问题，那么解决方案是什么呢？事实证明，当我们构建基于微服务的应用程序时，许多问题的解决方案可以在领域驱动设计中找到，这有点有趣，因为这本书是在13年前写的，所以就软件开发而言，它是一种古老的文本，它是非常有哲学动机的，但事实证明，它实际上有构建非常现代市场的解决方案，这在某种程度上是相当讽刺的，所以让我们多挖掘一下，我是

(14:07)可能我们中的许多人都读过，你知道开始读一些书吧，它谈到了领域模型的构件，对，有一个实体的概念，它是一个有持久性ID的对象，有一个价值对象的概念，它只是有价值但没有身份，有一个服务的概念，它包含业务逻辑，实际上不属于任何地方，或不属于实体或价值对象，然后当然有一个存储库的概念，真的只是

(14:41)对生活在数据库中的实体集合的抽象，我们都已经相当程度地内化了这些东西，你知道，也许不那么重视对象，尽管它们非常有价值，但我们都习惯于使用实体服务和资源库这样的术语，你知道，甚至今天的框架也支持这些，对吧，所以至少前四个事件是我们字典中的现代类型，但还有最后一个，就是聚合，当我读这本书时，你

(15:16)知道在2004年2005年的时候，它就像耶耶耶一样，我有点忽略了它，只是专注于实体和价值对象服务和存储库，但事实证明，当你在微服务应用程序中构建业务逻辑时，聚合是绝对必要的概念，所以什么是聚合，聚合是一个可以作为一个单元的对象集群，所以它是一种图，有一个根实体和可能的一个或多个其他价值对象或实体，只是

(15:56) 由根直接或间接地引用，所以它是一个对象的小集群，只是互相引用，事实证明，大多数商业实体的排序，如订单客户账户产品等，实际上是聚合，我们有点认为他们是实体，但实际上你知道，比如在一个订单的情况下，是有一个订单对象，但这不是真正的整个订单，对，一个订单也有行项目，它也可能有一个付款地址和一个交货地址等，可能

(16:30) 支付信息也是如此，所以你知道，我们有一个订单集合，它是这个对象的集群，所以它实际上是把一个领域模型分成几块的方式，可以作为一个单元来处理，你知道在其他事情中，它实际上说它实际上定义了删除一个订单的意思，所以当你删除一个订单时，你必须删除行项目和地址等等，所以这只是第一个好处，它实际上把一个领域模型分成几块，任何时候你可以模块化你的领域模型

(17:07)这很好，但实际上有一些比这更深的含义，所以有一组规则，聚合必须遵守，第一条规则是关于一个聚合如何引用另一个聚合，所以你知道，例如一个订单可以有一个残骸，它必须引用一个客户，而客户本身就是另一个聚合，但这里真正有趣的是，与其说有一个对象引用客户，实际上只是有客户的主键，所以一个订单

(17:47)不会有一个客户字段，但它会有一个客户ID字段，同样，一个订单行项目会有一个产品ID字段，而不仅仅是一个产品字段，这将是一个指向产品对象的艺术指针，这有点像等待什么，你知道你不能有外键和对象模型，对吧，如果你回去看看面向对象设计的文本，你的领域模型中的外键将被视为一种外套气味，应该立即删除，所以我们实际上有点儿

(18:22)在非常传统的面向对象的设计中违反了一些传统的规则，但是这样做的好处是，如果我们将领域模型模块化，这是好事，实际的块和实际的聚合体现在是非常松散的连接，因为它只是在主键方面，而不是一个适当的对象引用，所以这使得它在许多方面非常容易，实际上把订单放在订单服务中，客户放在客户服务中，产品放在产品服务中，因为没有对象引用，这是

(19:04)试图跨越流程边界，所以换句话说，聚合让你在微服务中分割你的对象模型，所以这是一件好事，所以这是一个直接的好处，还有一个规则，当我第一次读它的时候，好像没有任何意义，这个想法和规则是，一个事务应该只创建或更新一个聚合，所以换句话说，聚合是一种一致性的单位，这一点也让我震惊，因为你知道回来

(19:50)然后我在我的单体应用中使用我的关系数据库，我可以开始一个交易，更新我想要的数据，然后在晚上提交交易，我有很好的保证，现在有人说，对，Eric Evans说，不，不，交易必须被限制在范围内，这有点像，但这很愚蠢，没有正确利用我们现有的技术，但你知道你可以回想一下微服务的一个问题。

(20:25)和数据库的权利，一个交易必须适合在一个服务内，我们不能使用分配器交易来跨越服务边界，所以这种对我们的交易可以在我们的业务逻辑内做什么的限制正好符合我们在微服务架构内的技术限制，所以现在因为一个聚合体包含在一个服务内，一个交易只能更新或创建一个聚合体，交易被保证适合在一个服务边界内，所以我们已经排序

(21:02)解决了我们在微服务架构中必须处理的交易问题，所以这是你知道的巨大好处，不仅如此，这种交易范围实际上符合典型的无序列数据库的能力，所以在无序列数据库中，你只能更新单个文件或单个行或单个键值对，所以如果我们把一个聚合体持久化为一个文件，那么我们编写的交易在一个时间内只能创建或更新单个文件。

(21:44)时间，所以你知道它在那个层面上是完美的，你有一个迫切的问题，稍后就会出现，所以我我有意缩小了交易的含义范围，我认为你感到这种不适，不一定符合你可能有的实际业务需求，但我这样做是为了创造悬念，所以有趣的是，有这样一个问题，比如你的总量有多大，因为你知道在

(22:50)为了使某些东西能够真正成为原子性的，就像这个编程模型中的原子性单位现在是聚合，所以如果有一些东西恰好需要被添加，就需要真正的原子性，事实证明，许多事情不需要原子性，但如果它们需要，那么你需要在该事务中更新的东西必须适合一个聚合，事实证明，你经常可以选择你的聚合边界，所以我一直说，订单客户和

(23:26)产品是他们自己单独的聚合体，但这是我有意识地做出的设计决定，例如，你可以把客户的产品和订单都放在同一个聚合体中，所以你的系统只是由一个单一的聚合体组成，实际上我和某人谈过，他试图为湾区的一些创业公司这样做，因为他们想要一致性，结果发现这很糟糕，它没有工作，但是是的，但可以工作的东西将是让客户和他们的订单成为一个聚合体。

(24:03) 你可以想象，你知道一个大型的MongoDB文档包含一个客户和他们所有的订单，这将是一个单一的聚合，产品将是另一个聚合，这可能是实现你的应用程序的合法方式，如果你需要实现一个需要原子化的交易，在你知道涉及客户和他们所有的订单，但当然有一个有一个缺点是，你一次只能更新一个聚合，对更新是

(24:39)序列化的时候，它的更新服务和序列化的一样，这可能会导致糟糕的可用性和糟糕的用户体验，比如当两个订单，两个用户试图为不同的客户编辑同一个订单时，第二个人可能实际上无法看到他们的变化，因为像乐观的锁定异常，所以有一些问题，所以一般来说，最好有尽可能精细的聚合，但是，你确实有一个选择，所以，这是一个

(25:16) 部分答案是你如何使事情变得原子化，但如果你想更普遍地解决这个问题，你实际上必须使用另一种方法，我接下来要讲的不是正确的方法，所以是的，所以让我们想象一下，你知道订单和成本，你有你知道的订单，对，你有需求，同时客户有一个信用限额，我们需要始终确保这个信用限额永远不会被超过，所以如果像我展示的那样，如果他们在同一个数据库中，同一个单一的

(25:54)应用程序与单体数据库是微不足道的，但如果它们是属于不同服务的独立聚合体，并且你不能使用两阶段提交，那么你到底如何保持一致性，或者在这种情况下，我们如何可靠地执行这个业务规则或不变性，事实证明，解决方案是使用事件，所以我们实际上要放弃这种酸模型，转而使用最终一致的事件驱动模型，这个想法其实很简单，就是一个

(26:33)服务每当更新它的一个聚合体时就会发布一个事件，实际上严格来说，你可以想象一个聚合体当它的状态发生变化时实际上会发布事件，但你可以认为这发生在服务层面，所以每当有变化或有值得注意的事情发生时，你会发布一个事件，另一个服务会订阅这些事件，然后做出相应的反应，可以更新自己的状态，所以为了保持一些一致性，这将与订单处理的工作方式是

(27:12)如下，所以请求进来创建一个订单，订单服务将创建一个订单，但在这种待定状态下，比如还没有被验证，它将发布一个事件，说订单已经创建，这将被客户服务消耗，它将执行信用检查，实际上在这种情况下，在示例代码中，它实际上更新客户或试图更新客户，为该水保留信用，然后它将发布一个事件，表明这个结果。

(27:50) 信用检查要么是客户，要么是信用保留事件将被发布，如果它是如果信用能够被保留或如果信用限额被超过，它将发布一个信用检查失败的事件，所以订单服务将处理这些事件中的一个或另一个，然后以某种方式更新订单，要么批准订单，要么因为信用不足而拒绝它，所以在这种情况下，这就是你如何实现类似信用检查而不使用酸交易，当然在这种情况下

(28:32)你没有一个大的交易，而是有一系列的交易，有三个交易，一个在订单服务中，一个在客户服务中，然后一个回到客户服务中，它们是由事件驱动的，至少所有的，但第一个是由事件驱动的，所以这里有一个稍微不同的观点，对，所以创建订单被调用，订单被创建，事件被发布，得到的事件被客户服务消耗，更新订单，所以它更新了。

(29:08)客户预订了信贷，然后发布一个事件，说信贷已被预订，该事件被消耗，然后改变订单的状态，然后反过来可以发布另一个事件，这可能会触发履行等，所以这就是你如何在一个使用事件的微服务架构中实现维护数据一致性的排序，所以我们已经有点放弃了酸模型，我们现在使用这个最终一致的模型，有些人称之为基础，基本上是这样的

(29:47)可用的软状态最终是一致的，有一件事你可能会注意到，天哪，这现在有点复杂了，就像你知道在一个更普遍的情况下，你知道就像在一种常规的酸交易中，当一个业务规则被违反时，你可以简单地回滚交易，所有的变化都被撤销，但在这个模型中，你可能有一长串的步骤，只有当你到了第五步，你才意识到有些业务规则会被违反，你实际上最终有

(30:25)发布事件，然后将触发这些所谓的补偿交易的执行，这将明确地撤销他们在这个过程的前四个步骤中必须做出的改变，所以这有点复杂，你必须仔细考虑设计，以便使其发挥作用，你知道，如果你在两个银行账户之间转移资金，那么你从账户中扣款，然后当你试图将两个账户的款项存入时，你发现它已经关闭，所以你必须将账户中的款项存入。

(31:00)从账户中取出的钱，但你可能会有问题，因为有人可能已经关闭了从账户，现在你已经得到了这笔钱，我想银行赢了，所以有一些你知道的，但在现实世界中是这样的，我想如果你在银行工作，那么你可能知道，你交易的钱不倾向于使用酸交易转移，至少在我上次与在银行工作的人交谈时，他们是这样说的。

(31:37)这就是方法，但是为了让这个方法发挥作用，有一个有趣的小问题，为了让它可靠，你必须以原子的方式，而且是那种交易意义上的更新数据库，所以例如插入一个订单和发布一个事件，对，你必须做两件涉及两个不同的基础设施的事情，数据库和消息代理，而且它们必须以原子方式完成，因为例如如果你更新数据库，然后你不能发布一个事件，因为

(32:10)消息代理宕机或类似的情况，或者你在有机会发布消息之前就崩溃了，这是更有可能的，那么系统现在就处于不一致的状态，真正具有讽刺意味的是，这样做的标准方法是使用分布式事务，你知道你更新数据库，然后你发布一个消息给JMS消息代理，它参与了同一个事务，但由于我前面提到的原因，两阶段提交不是一个选项，所以我们需要一个不同的方法

(32:46)确保我们能够可靠地发布事件，所以这有点滑稽，就像我们决定我的单片机太难了，所以让我们使用微服务，结果发现，一旦你走了微服务路线，就有一大堆维护数据一致性的复杂性，有时当我给人们演讲时，你渴望他们的单片机应用程序，但是是的，但是单片机有很大的问题，所以事实证明，有几个不同的策略，你可以使用，在这个演讲中，我将会

(33:26)专注于其中一个叫做事件源，但还有其他的，所以例如eBay会使用这个来保持不同系统之间的数据一致性，所以它会使用应用程序事件模式，一个应用程序将一个事件插入到一个事件表中，所以在数据库中，你实际上基本上是把一个表当作一个消息队列，所以你更新说在这种情况下的订单，你将一个事件插入到订单的事件表中，这只是一个资产交易，然后在这之外，还有另一个

(34:06)过程是轮询事件表，把事件拉出来，然后发布做其他事情，在这种情况下发布它们，所以这是eBay使用的一种方法，然后还有其他的，所以像LinkedIn他们实际上是跟踪交易日志，数据库提交日志或交易日志，并基于此发布事件，这是一个非常非常有趣的技术，但我想谈的是事件源，如果顺便说一下，如果你去学习微服务i/o，你会有

(34:40) 找到一篇文章的链接，其中谈到了这些不同的方法，也是在微服务点IO上，这是这些模式生活的地方，你会发现大部分的写法，但我想谈的是事件源，这是一种编写业务逻辑的特殊方式，真的是所有关于事件，事实上事件源是一种以事件为中心的数据持久化方式，所以在某种程度上，应用程序不是更新数据库和发布一个事件，实际上，基本上有

(35:22)这是一个事件存储的概念，有点像一个数据库和一个消息中介，所以每当有什么变化，状态改变，你所做的就是发布一个事件到事件存储中，所以它是一个非常以事件为中心的数据存储方式，现在的细节将在一分钟内变得明显，其工作方式如下，所以对于你的每个聚合体，你确定状态改变的事件，还有所有领域的事件，更精确地说

(35:58)这可能是状态变化，但它们可能是其他重要的事情，比如信用额度被超过的事件，这对客户来说不是一个状态变化，但它只是代表了违反业务规则的失败尝试，所以你确定任何相关的事件，有趣的是，实际上还有一个研讨会的形式，你聚集学校的事件风暴，你把人们聚集在一个房间里，你头脑风暴，在一个特定的领域内有什么事件。

(36:34)你用它来实际设计你的业务逻辑，但你要弄清楚你的事件是什么，然后你定义事件类，使事件成为你的领域模型中的一等公民，所以在订单系统中，你实际上会有像订单创建或取消或发货到订单批准等类，所以这是你使用的第一件事，你把事件当作一等公民并明确建模，然后你做的第二件事是真的不同，你改变你如何坚持你的领域

(37:12) 对象，所以标准的方法当然是采取一个订单实体，你会用JPA hibernate或直接将其映射到订单表中的一行，对，这就是我们一直在坚持我们的领域对象的标准方式，你知道从一开始，或者至少从关系数据库被使用以来，就一直在坚持。

(37:52) 在实践中，如果你使用的是关系型数据库，你会有一个事件表，这几乎是你的全部数据库模式，因为每一个状态的变化最终都会导致一个事件被插入到这个表中，所以当一个订单被创建时，你所做的就是在这个表中保存一个订单创建的事件，同样，当它被批准时，你会插入一个事件来表明这一事实，同样，当它发货时，你会插入另一个事件，这就是你为一个特定订单存储的全部内容。

(38:33)事件的序列，所以没有其他的表，订单表消失了，订单里昂项目消失了，你可以想象，事件数据列是一团JSON，只是为了争论，因为这有点只是一些数据的序列化，然后当你想要一个订单的当前状态，就像你想我要加载订单实体，所以JP一个斜线hibernate会希望你有一组查询，并在这个系统的内存中重新构建一个订单对象，会发生什么？

(39:13)实际上是查询事件表，为一个给定的订单或任何你正在加载的实体加载事件，然后你重放这些事件来重新初始化一个空白的订单对象，所以你基本上是把事件流折叠在一起，以重建这个订单实体，是的，如果你有很多事件，有一种技术被称为快照，这意味着你不必回到时间的起点，加载订单，如果你有功能上的倾向，加载订单

(39:51)你可以认为，为了重建当前状态，你正在做的是对事件流进行功能折叠或减少，所以这就是事件或汇的本质，你正在存储事件而不是其他东西，事件是你架构中的记录系统，所以你的应用程序现在看起来像这样，你已经有了这个事件存储，你知道每个鸡蛋都在事件存储中被表示为一个事件序列，所以订单聚合是属于订单的，并且完全是私有的。

(40:32)服务的客户总量是属于客户服务的，并且完全是私有的，但他们实际上可以订阅彼此发布的事件，所以这就是你如何在这里得到事件驱动的架构，然后处理请求的方式如下，所以想象一个请求来到订单服务，你必须做的第一件事是找到该订单的事件，对吧，所以这是一个针对事件表的选择，如果你是这样存储事件的，你使用实例化一个新订单。

(41:05) 默认构造函数 你应用你从数据库加载的事件来重新初始化订单，稍后你会看到这个模型中的聚合体有一个应用方法，它接收一个事件并更新其当前状态，然后处理请求，这由一个命令来表示，聚合体的对象有一个处理方法，它接收一个命令，说做这个，比如储备信贷实际上并不改变域对象的状态，但它所做的是返回一个表示状态变化的事件序列。

(41:47)事件被应用于实际执行状态变化，然后事件，新的事件被保存在事件存储中，所以被附加到存储事件的事件表上，这是用乐观锁来处理两个请求同时试图更新同一个订单的情况，所以这是请求处理的一部分，所以在其中你知道一个订单将如何被取消或等等，或被标记为已发货或或什么，它的另一部分是，像客户的服务

(42:32)服务可以订阅事件，所以事件存储有一个订阅API，然后当这些事件被保存在事件存储中时，有兴趣的订阅者会得到通知，所以他们会得到事件，所以在这方面有点像一个消息经纪人，所以客户服务会得到事件，不管是什么订单事件，这将导致订单服务然后去更新客户的订单，如果它对那个特定事件有意义的话，这当然会导致

(43:14)一些客户事件被保存在事件存储中，然后会触发一些其他服务中的其他事件处理程序，所以这就是这个事件如何与事件驱动的架构相适应，你可以有其他的订阅者来执行任意的行动，所以当事件被通知时，事件订阅者可以更新一个视图，有一个相关的模式叫做命令查询责任隔离，为了便于查询

(43:51)或者为了支持查询，你维护一个非规范化的数据视图，这样该视图将通过订阅事件保持最新，所以一个很好的例子是使用弹性搜索，例如，你想在你的系统中添加文本搜索，你只需订阅由你的聚合发布的事件流，我们在弹性搜索中索引文件，其他订阅者可以发送通知，如电子邮件或文本消息或移动推送等，所以你知道，你可以做相当的

(44:29) 任意的事情，所以事件存储本身真的就像数据库的一部分，因为它有一个API用于插入给定实体的事件，也可以通过主键检索给定实体的事件，所以这非常像数据库，数据库部分可以是你知道的续集数据库，也可以是无续集数据库，但也有一个消息中介类型的API，你可以订阅已经保存在数据库中的事件，所以有些人是一种混合数据库消息中介，有些人有

(45:08)在像我的续集或Postgres orphan net land上面自己实现了它，有一个专门的事件存储，叫做事件存储或获取事件存储，然后我的创业公司工作的一部分，我们正在建立的也是一个事件存储，所以有各种不同的方式来排序建立这个建立和事件存储，所以事件源你知道有各种好处吧，比如它解决了日期你知道它让你建立一个事件驱动的架构，解决这些数据，支持这种基于聚合的发展概念所以

(45:46)你可以很容易地保持微服务之间的一致性，或者更具体地保持聚合体之间的一致性，你知道每一个状态变化都会导致一个事件，这些事件可以被机器学习算法所消耗，它们可以变成通知，被发送给用户，这也消除了或映射问题，因为我们不再在数据库中保存域对象和保存事件，这通常很容易更容易消毒，也因为我们在状态变化中进行验证，换句话说，每个状态变化都被代表了。

(46:34)通过一个事件对象，这意味着我们有这个内置的百分之百可靠的审计日志机制，就像你知道我过去工作的系统，在那里我们得到了实现审计日志的层，我们只是一种洒在整个代码中的一些审计日志服务，有时它是可靠的，有时不对，而这个它保证是可靠的，因为你一个状态变化的定义是一个事件在事件存储，这是相当好的，然后另一个好处是好，因为你是

(47:09) 保存每个领域对象的历史，你实际上可以回到过去，执行时间查询，找到两周前这个领域对象的状态，如果你需要进行诊断或监管机构想知道你是如何执行交易的，这可能是有用的，例如，你已经有了准确的历史，这是很强大的，然后也因为你已经保存了整个系统中发生的一切历史，理论上，所有的

(47:46)回到第一天，你实际上可以在今天实现一个功能，说这个功能这个模块被分析，分析事件流，例如可以建立一个视图，但它可以做一些有趣的分析，你实际上可以让它处理所有的事件，从第一天开始就在你的系统中发布，其效果就像你在第一天就实现了这个功能，而通常就像如果你今天实现它并部署它。

(48:22)今天，它只能做一些未来的事情，所以现在你已经有了一个时间机器，使你能够回到过去，实现一些功能，你知道，就像他们在第一天完成的那样，但是说到这里，你知道有一堆的缺点，就像先生需要重写应用程序，你知道你写领域逻辑的方式，你保存数据的方式是非常不同的，尽管它与迁移到微服务很好地结合起来，对吗？

(48:55) JPA到一个基于事件源的微服务架构，对，它可以很容易地适应，你知道有一个毫无疑问的学习曲线，对，你在用不同的风格编程，所以你知道这需要一点点的适应，另一个真正有趣的事情是，事件永远不会消失，对，所以我的意思是一种笑话，说它是一个历史记录，对，希望不会希望你不会用你的事件做出错误的设计决定，但

(49:31)有一些严重的问题，围绕着你知道进化你的事件的模式，如随着时间的推移添加新的属性，你需要比基尼考虑，因为一旦你在你的事件商店保存了一个事件，你知道可能要proce，可能永远要能够处理具有该特定结构的事件，所以你需要一些纪律也你只是你，但一般来说，你也可以插入一些像死有效种采取一个版本的事件和升级它到一个版本二事件时

(50:12)你把它加载进去，所以你的领域对象总是可以根据最新的事件来写，所以有一些事情你可以做，但是有一些有趣的挑战，还有一个问题，这是一个基于消息的系统，所以你知道消费者可能会多次看到同一个事件，所以在某些情况下，你将不得不做一些仔细的编码，以检测和忽略重复的事件，所以这可能是一个挑战，通常解决方案是非常简单的，虽然，然后有

(50:48) 另一个问题是查询事件或不完全是直接的，所以你知道想象一下你想找到你想找到所有的订单，比如说在一个特定的状态下，对不对，在那种传统的模式下，你只要从订单中选择状态等于X的地方，你会找到或匹配的行，但现在我的意思是如果这是一个非常简单的查询，但实际上为了弄清楚一个订单的当前状态，你实际上必须去找到该订单的事件，实际上

(51:29)除了最后一个对应于该订单的状态变化的事件外，其他的都被抛弃了，所以在这种情况下，是的，你会有像where和一些嵌套选择等于所需的状态，但你很容易想象，针对事件存储的更复杂的查询会变得非常复杂，而且可能效率很低，所以那里有一些真正的问题，还有一些事件存储，特别是那些基于无序列数据库的，只支持通过主键查询事件的数据库。

(52:13)所以你没有实际执行查询的能力，所以这就是为什么正如我前面提到的，你需要使用CQRS命令查询责任隔离和维护独立的视图，以支持你的查询，但这是另一个话题，但事实证明，一般来说，CQRS还是有价值的，就像它只是使用弹性搜索的一个概括，以支持文本查询，只是你最终不得不使用这些二级存储，为了

(52:52)在你的应用程序中支持任何类型的查询，除了通过主键加载这个实体的那种查询，那是一个完全不同的话题好吧，所以我只是想通过快速谈论显示这种订单和客户用例的一些示例代码来结束，所以在实际的应用程序中，你可以在github中找到，实际上有三个服务，有客户服务，有客户汇总，有订单服务，有订单汇总和

(53:31)然后实际上有一个订单历史服务，它实现了这些非规范化的视图之一，所以它是一个CQRS视图，它实际上使用MongoDB，在内部，每个客户都有一个MongoDB文档，其中有一个应用程序的订单属性，是该特定客户的订单集合，当MongoDB通过订阅事件保持最新，所以这是一种应用程序的大画面视图，如果你深入到客户服务，就像是的有

(54:08)一个客户控制器，领域逻辑包括一个客户服务，客户 好的，客户集合，然后有一些事件处理程序，这些程序订阅了通过另一个服务发布的订单事件，该系统实际上也在使用Kafka，因为订单之间有一些其他的通信，订单服务实际上在发布事件，所以客户服务在发布事件，其他事件或其他消息，他们应该说它被消费了。

(54:47)通过Kafka的订单服务以及事件存储，但这是我们的排序，你可以稍后再看代码，所以这里是客户汇总，所以它有一些状态，有一个 crit字段，这是一个信用额度，也有信用保留，这是一个字段，是从订单ID到钱的映射，所以它在跟踪订单1 2 3 4已经保留了1200美元的可用信用，还有一组处理方法，所以这些是接受一个命令，代表一个请求到

(55:29)对客户做一些事情，比如创建客户或储备信贷，他们返回一个事件列表，所以他们不做命令，不执行状态变化，他们返回事件，代表状态变化，也有应用方法，采取一个事件，执行状态变化，所以有一种非常结构化的方式来编写业务逻辑，在本质上，如果你考虑一下，所以在旧的编写代码的方式，你会有一个储备信贷方法，采取一些参数，使用一些实现。

(56:08)一些类似于业务规则的东西，然后在这个模型中做了一个状态更新，这个方法被分成了两个，它被分成了一个进程方法，正在做一些忙于实现业务规则的事情，然后返回一个代表状态变化的事件，然后状态变化被一个apply方法处理，这个方法接受事件并只是更新状态，所以这是一种相同的业务逻辑，我们只是把它分成了两个，这里是聚合本身，它实现了反射，所以是实现了一个基类

(56:50)称为反射式可变命令处理聚合体，所以它有点像遵循Spring的命名惯例，但它是有意义的，因为它是一个知道如何处理命令的聚合体，它是可变的，因为如果你是用学者编程，我会有不可变的聚合体，但这是Java，所以我把它们变了，所以它们是可变的，它实际上是使用反射来分派事件类型和命令类型到适当的应用方法或处理方法，所以这是

(57:26) 如果你是这样解释的，我已经为你解开了名字，所以专业的流程方法，你知道有几个这样的方法，第二个流程方法是接受一个保留的信贷命令，这是一个有趣的方法，因为它有一行业务逻辑，所以它说如果可用的信贷大于或等于订单总额，那么返回信贷保留信贷客户信贷保留事件，所以我们已经保留，我们有信贷可以保留，但如果没有的话

(58:08) 足够的信用，它返回一个客户信用额度超过的事件，这是一个错字，所以这是一个你知道的，这是一个实现业务规则的方法的一个很好的例子，然后如果我们看一下应用方法，这些真的很简单，所以相应的客户信用保留事件应用方法只是把一个条目放入信用保留的地图中，所以这就是那个，所以应用方法中没有业务逻辑，你知道要做什么已经有了。

(58:45)由过程方法决定，应用方法只是应用变化，然后，我应该提到，当从事件存储加载时，这些方法用于重建一个集合的当前状态，所以另一个有趣的是，当客户信用额度被超过时，这并不表明状态变化，而是表明业务规则被违反，所以应用方法实际上并没有做任何事情。

(59:27)一个新的客户，所以它只是调用客户服务中的创建客户方法，这里是客户服务，所以创建方法只是一个衬词，这是因为它是使用这个被称为聚合库的辅助类编写的，它有一个保存方法，接收一个命令，所以在这种情况下，它是一个创建客户的命令，保存的作用是创建一个你知道的客户聚合，使用其默认构造函数，通过调用处理方法处理命令，通过调用应用和应用事件。

(1:00:13) 然后它将事件保存在事件存储器中，这样，每当你需要创建一个新的聚合时，你将重复这四个步骤，所以保存方法只是一种像为你封装的模板，所以它的事情最终是你知道你写的东西最终是非常简单的，所以这就是服务，这是一个事件处理程序，所以它被注释为事件订阅者，这实际上最终被一个弹簧豆后处理器接收，然后结束

(1:00:52) 使用传入的订阅名称订阅事件存储，然后你可以看到有一个事件处理方法，处理订单创建事件，记得当收到订单创意事件时，它必须做的是告诉客户保留信用，所以这就是事件处理方法所做的，它在传入的上下文上调用更新方法，这就像保存方法，这是一个帮助方法，简化了你如何互动。

(1:01:29)与事件存储，所以它在做什么，所以它说你知道你告诉update去寻找客户，找到一个具有指定客户ID的客户，并处理储备信贷命令，所以在封面下实际上是加载客户处理命令，应用事件并在事件存储中保存这些新事件，所以它只是封装了那块模板代码，然后有一些有一些丑陋的代码，它就像这样的代码写在一个反应式风格和使用

(1:02:06) Java有八个可完成的期货，如果你问为什么，那么至少它们是有用的，但是方法的名字都是错的，比如handle async真的应该叫flatmap，如果你熟悉Scala的话，或者实际上更好，它们需要用方法来恢复，但是基本上这是在处理这样的情况：一个订单是用无效的客户ID创建的，所以没有实际的总量进入数据库，所以你得到一个实体未找到。

(1:02:42) 异常，这里的这段代码实际上是通过使用spring cloud stream向订单服务发送一个消息，说你告诉我为这个客户保留信用，但这个客户并不存在，这将导致订单被取消，所以spring cloud streams实际上是通过Kafka发布一个消息，所以这里有一种基于事件的次级后方通道，正在使用，这都是抽象出来的，这个去你知道你

(1:03:23) 上网，你可以看到所有丑陋细节的代码，所以，这实际上几乎是我的谈话，所以总结一下，对，所以聚合真的是你的业务逻辑的构建块，在你的麦克中，基于服务的应用程序，一般来说，这就像去读领域驱动设计书，因为那里有很多概念，聚合和战略设计概念，如有界背景，令人难以置信地适用于微服务架构，你想使用

(1:04:00)事件，以保持你的聚合或服务之间的一致性，事件来源是一个非常好的方式来暗示一个事件驱动的架构，所以，是的，这就是我的谈话，感谢你的收听，我希望你觉得它有用，这是我所有的联系信息，所以谢谢你，我想还有时间提问，如果你坚持，如果你不想马上去酒吧，嗯，是的，哦，这是一个非常好的问题，所以我用什么做事件存储，以便我实际上，我其实有两个

(1:04:57)答案，所以，如果你到eventuate dot IO，有一个有一个托管版本，所以这实际上是利用AWS的功能来提供事件存储，但在接下来的一周左右，我实际上发布了一个开源版本，你可以在前提下运行，这只是要利用sequel数据库和Kafka 是啊是啊嗯是啊所以所以DF，所以

(1:06:18)的录音 是的，问题是，如果你正在重构一个现有的单体，你可以使用什么方法来发布事件，所以是的，你有一个选择，所以一个是它的工作原理，比如第一，你几乎总是需要做一些事情，特别是因为整合一个单体和一个微服务，你几乎需要事件来回，以保持数据同步，这是一部分，所以你喜欢你需要做一些事情，然后是有不同的模式。

(1:06:58)你可以应用，我认为交易日志跟踪太有问题了，因为你看到的是数据库模式的低级变化，你必须对业务事件进行逆向工程，所以让你知道排除这个问题，所以接下来的事情是，我应该使用事件源还是应该使用应用事件，你知道它的一部分是排序，你是什么，它就像任何一个将工作的权利，它的一部分是排序你的偏好是什么，然后也由时间如果你打算使用事件，你

(1:07:42) 在关系型数据库的基础上，你可能不会使用，你可能最终发现使用事件源是非常直接的，实际上，哦，等等，这是一个春季会议，对不起，所以问题是，如果你正在做一个绿地项目，我是否会使用akka，这又是一个有趣的问题，一方面说，你知道光带

(1:08:45)以前被称为typesafe的人有一个相当有趣的堆栈，你知道我会做什么，我不会做什么，我喜欢演员，我喜欢在服务中使用演员，但我不太愿意做的是使用演员广告来组织整个系统的范式，我觉得使用那种更开放和更少的专有技术更好，例如，像演员远程，你知道你知道我的意思，加上这是一个春季会议，我们喜欢春天，不是吗，其实我是

(1:09:33)我告诉你，我已经没有时间了，但我会把你的问题下线，所以再次感谢你的聆听，我希望你觉得这很有用。