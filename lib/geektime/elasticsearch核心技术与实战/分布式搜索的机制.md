---
dg-publish: true
title: 分布式搜索的机制
createTime: 2023-06-08 21:18  
---

# 分布式搜索的运行机制

## 2阶段执行

Query-then-Fetch

### Query

- 用户发出搜索请求后，节点收到请求，以Coordinating节点的身份，在主副分片中随机选择3个分片，发送查询请求
- 被选中的分片执行查询，进行排序，然后每个分片都会返回From+Size排序后的文档id和排序值，给到Coordinating节点

### Fetch

- Coordinating Node将Query阶段，从每个分片获取的排序后的文档id列表，重新进行排序，选取From到From+size个文档id
- 以mulit get请求的方式到相应的分片获取详细的文档数据

### Query-then-Fetch 潜在问题

- 性能问题
	- 每个分片需要查询的文档数= from+ size
	- 最终协调节点需要处理： number_of_shard * (from + size)
	- 深度分页
- 相关性算分
	- 制定参数dsf_query_then_fetch
	- 每个分片都基于自己的分片上的数据进行相关度计算，会导致打分偏离的情况，特别是数据量很少时，相关性算分在分片之间是相互独立，当文档数少的情况下，如果主分片> 1,主分片越多，相关性算分越不准


## 排序及DOC values

单字段排序：
```http
POST /kibana_sample_data_ecommerce/_search

{

  "size": 5,

  "query": {

    "match_all": {

  

    }

  },

  "sort": [

    {"order_date": {"order": "desc"}}

  ]

}
```

多字段排序：
```http
#多字段排序

POST /kibana_sample_data_ecommerce/_search

{

  "size": 5,

  "query": {

    "match_all": {

  

    }

  },

  "sort": [

    {"order_date": {"order": "desc"}},

    {"_doc":{"order": "asc"}},

    {"_score":{ "order": "desc"}}

  ]

}
```

**当使用text字段进行排序直接报错**，要使用Feilddata

### 排序过程

- 排序是针对字段原始内容进行的，倒排索引无法发挥作用
- 需要用到正排索引，通过id获取字段原始内容
- Es 有2中实现方式
	- Fielddata
	- Doc values（列存储，对text类型无效）

![[Pasted image 20230608214408.png]]

### 关闭doc values

- 默认开启，可以通过Mapping 设置关闭
	- 可以增加索引速度，减少磁盘空间
- 如果重新打开，需要重新建索引
- 如果明确不需要排序及聚合分析的时候可以关闭

# 地址

此文章为6月day8 学习笔记，内容来源于极客时间《https://time.geekbang.org/course/detail/100030501-114564》