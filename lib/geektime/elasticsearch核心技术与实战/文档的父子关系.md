---
dg-publish: true
title: 文档的父子关系
createTime: 2023-06-17 23:13  
---

## Parent / child 

- 对象和Nested对象的局限性
	- 每次更新，需要重新索引整个文档
- es提供了类似关系型数据库中的join实现，使用join 实现，可以维护Parent/Child 关系，从而分离两个对象
	- 父文档和子文档时2个独立的文档
	- 更新父文档无需更新索引子文档，子文档被添加，更新或删除也不会影响到父文档和其他子文档

### 父子关系

1. 设置索引mapping
2. 索引父子文档
3. 按需查询文档

#### 设置mapping

![[Pasted image 20230617231811.png]]

索引父文档

![[Pasted image 20230617231849.png]]

子文档
![[Pasted image 20230617232830.png]]

#### 父文档和子文档必须在相同的分片上
- 确保查询join的性能
#### 当指定子文档时候，必须指定它的父文档id
- 使用route参数保证，分配到相同的分片

```http
#索引父文档

PUT my_blogs/_doc/blog2

{

  "title":"Learning Hadoop",

  "content":"learning Hadoop",

    "blog_comments_relation":{

    "name":"blog"

  }

}

#索引子文档

PUT my_blogs/_doc/comment2?routing=blog2

{

  "comment":"I like Hadoop!!!!!",

  "username":"Jack",

  "blog_comments_relation":{

    "name":"comment",

    "parent":"blog2"

  }

}
```


针对查询
```http
POST my_blogs/_search

{

  

}
```


```http
# Has Child 查询,返回父文档

POST my_blogs/_search

{

  "query": {

    "has_child": {

      "type": "comment",

      "query" : {

                "match": {

                    "username" : "Jack"

                }

            }

    }

  }

}
```


```http
  

#通过ID ，访问子文档

GET my_blogs/_doc/comment3

#通过ID和routing ，访问子文档

GET my_blogs/_doc/comment3?routing=blog2
```


嵌套对象 vs 父子文档

- 优点
	- nested 文档存储在一起， 读取性能高
	- parent 父子文档独立更新
- 缺点
	- nested 更新嵌套的子文档，需更新整个文档
	-  parent 需要额外的内存维护关系，读取性能更差
- 适用场景
	- nested子文档偶尔更新，以查询为主
	- parent 子文档更新频繁