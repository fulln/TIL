---
dg-publish: true
---

## 课程内容

聚合的封装，它的目的是确保不变规则,为了保持这种规则需要做的一些处理

Repository是以聚合为单位进行持久化.

### 实现不变规则

1. 业务规则必须在领域层来实现。
2. 由于聚合根已经拥有了实现业务规则所需要的数据，所以我们应该直接在聚合根里实现业务规则，而不是领域服务里。

如果聚合根没有足够的数据，需要从数据库取的话，那么这个逻辑就要放到领域服务了。

### 创建聚合的另一种做法

用了一个叫做**assembler**的对象进行领域对象和 DTO 之间的转换。
**assembler** 用到了在应用层定义的 DTO（也就是 CreateEmpRequest），所以只能放在应用层，不能放到领域层，否则就会破坏层间依赖

####  Builder和assembler 比较

工厂位于领域层，入口参数可以是基本类型、领域对象或者在领域层定义的 DTO，但不能是在应用层定义的 DTO。

- builder模式
用工厂模式的好处是，对领域逻辑的封装更彻底一些。
使用工厂模式的代价就是，如果需要在领域层定义 DTO，或者采用 Builder 模式，就要写更多的代码和数据转换逻辑

- Assembler
使用 asembler 的优点是代码比较简洁
代价是，从理论上来说，有时领域逻辑可能稍有泄漏。对于“组织应该有效”这条业务规则，尽管规则的实现仍然在领域层，但却是从应用层调用的。

>工厂的参数不能是应用层定义的 DTO。这个规则可以推广到整个领域层。也就是领域层中所有对象，包括领域对象、领域服务、工厂、仓库，对外暴露的方法的输入和输出参数，都只能是领域对象、基本类型，或者领域层内部定义的 DTO。


### 新建聚合的持久化

repository（仓库） 和传统的 DAO（数据访问对象） 虽然都用来访问数据库，但有一个重要的区别——DAO 是针对单个表的，而 Repository 是针对整个聚合的

### 包结构

- 领域（domain）层
	- 聚合根
	- 领域服务
	- 仓库接口
	- 非聚合根的领域对象和枚举类。
- 应用（application）层
	- 应用服务
	- 配合应用服务的装配器
	- 应用服务对应的DTO
- 适配器（adapter）层
	- presise 层

### 聚合修改所面临的问题

1. 虽然对聚合整体而言是“修改”，但具体到聚合内部的各个对象和相应的数据表来说，却不一定都是 “update”。

#### 标记领域对象的修改状态

在每个实体中增加一个“修改状态”，在程序中合适的地方把状态设置正确，然后在 Repository 里根据状态进行相应的处理。





## 课程地址

https://time.geekbang.org/column/article/621713