#设计思想 #DDD  #极客时间 

##  31｜CQRS（上）：实现查询功能有什么诀窍？

### 查询功能遇到的问题

在DDD情况下查询复杂

- 第一步，工时记录服务会调用 EffortRecordRepository，根据工时项 ID 取得一堆 EffortRecord （工时记录）实体。
- 第二步，再根据每个工时记录实体中的员工 ID，调用 EmpRepository ，为每个工时记录取得相应的员工实体。这里要注意避免对同一个员工实体重复查询数据库。
- 第三步，把所有工时记录和对应的员工实体信息拼成相应的 EmpEffortRecordDto ，排序后组装成列表返回。

上面的做法确实符合我们之前说的“代码和模型一致”这个要求，但是你可能已经发现这么做会带来的问题了。

- 程序编写比较麻烦，原来一句 SQL 就可以解决的问题，现在要分几步实现。
- 这样的程序可能带来性能问题。

把增、删、改功能称为 Command（命令），把查询称为 Query，这两种功能的职责不同，应该采用不同的方式来处理，因此叫做“命令查询职责分离”（Command Query Responsibility Segregation ），简称 CQRS。我们可以先粗放一点来理解，一共是两条规则。

**第一，命令要走领域模型。**

**第二，查询不走领域模型，直接用 SQL 和 DTO。**

### 代码结构分离

查询处理器，你会发现里面根本就没有领域层了，当然也就没有领域对象了。这里直接用 EmpEffortRecordDto 来表示数据。应用服务调用仓库，仓库里用 SQL 语句进行连表查询，得到的数据直接填到 DTO 里。应用服务可能还要对 DTO 再做少许加工，就可以直接返回了。

### 数据库结构分离

程序里的查询模型和数据库里的表架构不一致。这是因为，数据库里的表结构，或者说物理数据模型，是根据领域模型，而不是查询模型设计的。从物理数据模型到程序中的查询模型的转换，是通过 SQL 完成的。而这种转换需要表连接，就可能造成性能问题。

命令处理器对命令模型里的表进行操作后，要把数据同步给查询模型。有多种同步方案可供选择，比如说，命令模型中的仓库，同时写两边的数据表，或者使用触发器，还可以用同步或异步的事件驱动机制。

### 反规范化设计

在命令模型里，一般是不主张违反范式的，这是因为违反范式必然造成数据冗余，数据冗余就会造成潜在的数据不一致风险。而在查询模型中，不仅允许，甚至是鼓励反规范化设计。这是因为，对于查询模型，反规范化的风险是可控的。就算数据发生了不一致，总可以从命令模型里按正确的逻辑重新生成一遍。


### 性能的提升代价

数据库结构分离策略的好处是提高了性能。但这么做也有明显代价，包括后面三个方面。
1. 增加了两种数据模型同步的复杂性和出错的可能性。
2. 数据同步可能带来性能损失。
3. 会占用额外的存储空间。

## 地址

此文章为2月day21 学习笔记，内容来源于极客时间《[31｜CQRS（上）：实现查询功能有什么诀窍？ (geekbang.org)](https://time.geekbang.org/column/article/633063)》
