---
dg-publish: true
---

#算法 #排序 #alg #极客时间 

# 14 | 排序优化：如何实现一个通用的、高性能的排序函数？

### 如何选择合适的排序算法？

如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

### 如何优化快速排序？

为什么最坏情况下快速排序的时间复杂度是 O(n2) 呢？我们前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理。

#### 如何来选择分区点呢？

**被分区点分开的两个分区中，数据的数量差不多。**

#### 两个比较常用、比较简单的分区算法

> [!ABSTRACT]+ 三数取中法
> 我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

> [!abstract]+ 随机法
> 随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。


### qsort 分析

1. qsort() 会优先使用归并排序来排序输入数据
2. 要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。

qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。



### 总结

在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。



# 地址

此文章为4月day16 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/42359》