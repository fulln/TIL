---
dg-publish: true
---

#链表 #算法 #java #极客时间 

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

一个经典的链表应用场景，那就是 LRU 缓存淘汰算法。

### 常见淘汰策略

1. FIFO
2. LFU
3. LRU

### 主要的链表结构

#### 链表存储结构

链表它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用

常见的链表结构：

1. 单链表
2. 双向链表
3. 循环链表

##### 链表常见名词

1. 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的**结点**。
2. 为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作**后继指针next**。
3. 习惯性地把第一个结点叫作**头结点**
4. 最后一个结点叫作**尾结点**，尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。
5. **循环链表**是一种特殊的单链表，循环链表的尾结点指针是指向链表的头结点
6. **双向链表**，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
7. 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，虽然两个指针比较浪费存储空间，但可以支持双向遍历


##### 链表常见操作

1. 在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。
2. 链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。
3. 对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据


##### 优化

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。


### 基于链表实现LRU

当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
	1. 如果此时缓存未满，则将此结点直接插入到链表的头部；
	2. 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

```java
package me.fulln.alg;  
  
import java.util.LinkedHashMap;  
  
public class LRUMap extends LinkedHashMap<Integer, Integer> {  
  
private int capacity;  
  
public LRUMap(int capacity) {  
super(capacity, 0.75f, true);  
this.capacity = capacity;  
}  
  
public Integer get(int key) {  
return super.get(key);  
}  
  
@Override  
protected boolean removeEldestEntry(java.util.Map.Entry<Integer, Integer> eldest) {  
return size() > capacity;  
}  
}
```

实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，


# 地址

此文章为4月day8 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/41013》