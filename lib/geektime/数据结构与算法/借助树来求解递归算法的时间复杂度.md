---
dg-publish: true
title: 借助树来求解递归算法的时间复杂度
createTime: 2023-08-15 23:02  
---

# 借助树来求解递归算法的时间复杂度

如何利用递推公式，求解归并排序、快速排序的时间复杂度，但是，有些情况，比如快排的平均时间复杂度的分析，用递推公式的话，会涉及非常复杂的数学推导

借助递归树来分析递归算法的时间复杂度。

### 思想
递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。

### 归并排序
归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。

#### 分析快速排序的时间复杂度

快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(2n​)+n，很容易就能推导出时间复杂度是 O(nlogn)。但是，我们并不可能每次分区都这么幸运，正好一分为二。

对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。

#### 斐波那契数列的时间复杂度

每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 22。依次类推，第 k 层的时间消耗就是 2k−1，那整个算法的总的时间消耗就是每一层时间消耗之和。

#### 全排列的时间复杂度

![](https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg?wh=1142*936)

n∗(n−1)∗(n−2)∗...∗2∗1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n∗n!，也就是说，全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n∗n!)

# 地址

此文章为8月day15 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/69388》