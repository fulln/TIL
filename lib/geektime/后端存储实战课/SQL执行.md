---
dg-publish: true
---
#lib #geektime #后端存储实战课 

# 10 | 走进黑盒：SQL是如何在数据库中执行的？

### 服务器执行

1. 执行器
2. 存储引擎

#### 如何执行

```sql
SELECT u.id AS user_id, u.name AS user_name, o.id AS order_id
FROM users u INNER JOIN orders o ON u.id = o.user_id
WHERE u.id > 50
```

把这一串文本解析成便于程序处理的结构化数据，这就是一个通用的语法解析过程。

转换后的结构化数据，就是一棵树，这个树的名字叫抽象语法树（AST，Abstract Syntax Tree）。

#### 主要优化点

1. 尽早地执行投影，去除不需要的列；
2. 尽早地执行数据过滤，去除不需要的行。

### sql如何在存储引擎执行

MySQL它在设计层面对存储引擎做了抽象，它的存储引擎是可以替换的。

1. 我们知道了 InnoDB 的索引实现后，就很容易明白为什么主键不能太长，因为表的每个索引保存的都是主键的值，过长的主键会导致每一个索引都很大
2. 有的时候明明有索引却不能命中的原因是，数据库在对物理执行计划优化的时候，评估发现不走索引，直接全表扫描是更优的选择

# 11 | MySQL如何应对高并发（一）：使用缓存保护MySQL


### 更新缓存的最佳方式

Redis 是一个使用内存保存数据的高性能 KV 数据库，它的高性能主要来自于：

1. 简单的数据结构；
2. 使用内存存储数据。

从设计上来说，Redis 牺牲了大部分功能，牺牲了数据可靠性，换取了高性能。但也正是这些特性，使得 Redis 特别适合用来做 MySQL 的前置缓存。

即使只是把 Redis 作为缓存来使用，我们在设计 Redis 缓存的时候，也必须要考虑 Redis 的这种“数据不可靠性”，或者换句话说，我们的程序在使用 Redis 的时候，要能兼容 Redis 丢数据的情况，做到即使 Redis 发生了丢数据的情况，也不影响系统的数据准确性。


### 注意缓存穿透引起雪崩

如果我们的缓存命中率比较低，就会出现大量“缓存穿透”的情况。缓存穿透指的是，在读数据的时候，没有命中缓存，请求“穿透”了缓存，直接访问后端数据库的情况。

当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。

1. 可以采用灰度发布的方式，先接入少量请求，再逐步增加系统的请求数量，直到全部请求都切换完成。
2. 在系统启动的时候对缓存进行预热

**当发生缓存穿透时，如果从数据库中读取数据的时间比较长，也容易引起数据库雪崩。**

并没有一种方法能应对所有的场景，你需要针对业务场景来选择合适解决方案。比如说，可以牺牲缓存的时效性和利用率，缓存所有的数据，放弃 Read Through 策略所有的请求，只读缓存不读数据库，用后台线程来定时更新缓存数据。




# 地址

此文章为3月day27 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/213176》，




