#mysql  

## 结构

### 查询缓存
根据key默认先从缓存中获取,mysql8.0后删除该功能

### 分析器
语法分析，sql异常判断

### 优化器

- 扫描行数
	- 根据索引区分度来估算
- 是否使用临时表
- 是否排序	

### 执行器

#### 执行步骤
- 查询
	- 从第一行到最后一行查询
	- 有索引就走索引的接口查询
- 删除
	- innodb 删除一页上面的数据 
		- 整个数据页可以被复用
		- 记录复用和数据页复用不同
		
					记录的复用，只限于符合范围条件的数据
					数据页可复用 表示可以用到任何位置
						如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用
		 - 删除表内所有数据
			所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小			


	可以在执行器中看row_examind影响行数
	count(*)
		MyISAM 表虽然 count(*) 很快，但是不支持事务；
		show table status 命令虽然返回很快，但是不准确
		InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。
		缓存
			可能会缓存丢失
			即使 Redis 正常工作，这个计数值还是逻辑上不精确的。
		数据库保存
		性能问题
			如果 count 函数的参数不是 NULL，累计值就加 1，否则不加
			现在的优化器只优化了 count(*) 的语义为“取行数”
				count(*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。
			count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加
			count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
			count(字段)
				这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加
				如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
			按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)，所以我建议你，尽量使用 count(*)
	order by
		using fileSort
			执行流程
				1.初始化 sort_buffer，确定放入 name、city、age 这三个字段；
				2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
				3. 主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
				4. 从索引 city 取下一个记录的主键 id；
				5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；
				6.对 sort_buffer 中的数据按照字段 name 做快速排序；
				7.按照排序结果取前 1000 行返回给客户端。
			全字段排序
		max_length_for_sort_data
			16
			MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。
		sort_buffer_size
			“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序
			如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。
		sort_key, rowid
			执行流程
				初始化 sort_buffer，确定放入两个字段，即 name 和 id；
				从索引 city 找到第一个满足 city='杭州’条件的主键 id
				到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；
				从索引 city 取下一个记录的主键 id；
				重复步骤 3、4 直到不满足 city='杭州’条件为止，
				对 sort_buffer 中的数据按照字段 name 进行排序；
				遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。
			单行很大
			rowid 排序
		覆盖索引
			Using index
			而且由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了
	order by rand()
		一般会用到rowid排序
		内存临时表
		磁盘临时表
			超过tmp_table_size 默认16M
			优先队列排序
				类似 数据存在堆上面
				不需要临时文件
		优化的随机排列方式
			一般建议放到代码层操作

连接器
	短链接风暴
		max_connections
			控制一个 MySQL 实例同时存在的连接数的上限
		kill connection + id
			从服务端断开连接
			从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL 一直没恢复”。
		–skip-grant-tables
			整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。
	show processlist
		查询所有mysql链接线程
		information_schema.innodb_trx
			从该表可以查询出在事务中的trx_mysql_thread_id

基础概念
	内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”
		刷脏页策略
			innodb_io_capacity
			innodb_max_dirty_pages_pct
				默认75%
			根据脏页百分比和 redo log checkPoint 计算得到真正的刷脏页的速度
			innodb_flush_neighbors
				mysql 8 默认0
				可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。
	内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”
	flush
		将内存数据刷到磁盘
		可能造成mysql抖动
		场景
			1. redo log写满
			2.系统内存不足。
				是常态
				3种情况
					1.未使用
					2.使用了并且是干净页
					3. 使用了并且是脏页
						读入数据需要释放内存,而刚好释放的是脏页
						控制脏页比例
			3, 系统空闲时
			4. mysql 正常关闭
	表共享空间
		innodb_file_per_table
			on 表示单独存储
			off 表示数据也存到表共享空间
	用递增主键做索引
		如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分
		防止表空洞
			alter table A engine=InnoDB 命令来重建表
				非online ddl 5.6版本之前
				online ddl
					gh-ost
				对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的
				原地操作 inplace
					ALGORITHM=inplace 默认加上了
					加字段也是原地操作
					会占用临时空间的
					会写log
				在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。
	慢查询
		索引没设计好
			紧急创建索引
				MySQL 5.6 版本以后，创建索引都支持 Online DDL
				比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库 A、备库 B，这个方案的大致流程是这样的：


在备库 B 上执行 set sql_log_bin=off，也就是不写 binlog，然后执行 alter table 语句加上索引；

执行主备切换；

这时候主库是 B，备库是 A。在 A 上执行 set sql_log_bin=off，然后执行 alter table 语句加上索引。
这是一个“古老”的 DDL 方案。平时在做变更的时候，你应该考虑类似 gh-ost 这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的。
		sql没写好
			query_rewrite
				mysql> insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");
				call query_rewrite.flush_rewrite_rules();
		mysql选错索引
	qps突增
		下服务
		sql重写
