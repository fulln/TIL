---
dg-publish: true
title: 数据迁移
createTime: 2023-07-19 23:41  
---


##  数据迁移

### 数据备份工具

![](https://static001.geekbang.org/resource/image/e3/d0/e341443c3cc11c3b04d17a28134cbbd0.png?wh=1920x712)


### innodb_autoinc_lock_mode 
是 InnoDB 引擎里面控制自增主键生成策略的参数，它有三个取值。

- 0：使用表自增锁，但是锁在 INSERT 语句结束之后就释放了。
- 1：使用表自增锁，如果是普通的 INSERT INTO VALUE 或者 INSERT INTO VALUES 语句，申请了主键就释放锁，而不是整个 INSERT 语句执行完毕才释放。如果是 INSERT SELECT 等语句，因为无法确定究竟要插入多少行，所以都是整个 INSERT 语句执行完毕才释放。
- 2：使用表自增锁，所有的语句都是申请了主键就立刻释放。

### 数据迁移解决方案

![](https://static001.geekbang.org/resource/image/2b/20/2b23d430a4284b860be2876f11174c20.png?wh=1920x1222)

1. 加快导入导出
	1. 关闭唯一性检查和外键检查，源表已经保证了这两项，所以目标表并不需要检查。
	2. 关闭 binlog，毕竟导入数据用不着 binlog。
	3. 调整 redo log 的刷盘时机，把 innodb_flush_log_at_trx_commit 设置为 0。
2. 第一次校验与修复
3. 业务开启双写，以源表为准
	1. 侵入式
		1. 侵入式方案就是直接修改业务代码。要求业务代码在写了源表之后再写目标表。但是侵入式方案是不太可行的，或者说代价很高。因为这意味着所有的业务都要检查一遍，然后修改。既然修改了，那自然还要测试。所以，一句话总结就是工作量大还容易出错。
	2. 非侵入式
		1. AOP
		2. 数据库操作抽象

不管你采用哪个方案，你都要确保一个东西，就是双写可以在运行期随时切换状态，单写源表、先写源表、先写目标表、单写目标表都可以。
4. 主键问题
需要在写入源表的时候拿到自增主键，然后写入目标表的时候设置好主键。
innodb_autoinc_lock_mode 取值会影响自增主键的连续性
5. 增量校验和数据修复
利用 binlog。相比之下 binlog 更加高级一点，在面试的时候你应该优先考虑用这个方案。
6. 利用更新时间戳
利用更新时间戳找出最近更新过的记录，然后再去目标表里面找到对应的数据
7. 主从同步延迟引发的问题
简单粗暴的方法就是全部读主库，校验和修复都以主库数据为准。缺点就是对主库的压力会比较大。

校验和修复的时候都要小心主从同步的问题，如果校验和修复都使用从库的话，那么就会出现校验出错，或者修复出错的情况。按照道理来说，强制走主库就可以解决问题，但是这样对主库的压力是比较大的。
8. 切换双写顺序
要引入一个双写的时候先写目标表，且业务读目标表的步骤。这样万一切换到写目标表出了问题还可以回滚
9. 保持增量校验和修复
切换了双写顺序之后，保持增量校验和修复是顺理成章的，方案和步骤 5 一样。不过步骤 5 的校验和修复都是以源表为准，那么在这一步，就是以目标表为准。




# 地址 

此文章为7月day19 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/676586》