---
dg-publish: true
title: 分库分表无分库分表键查询
createTime: 2023-07-29 23:08  
---


##  分库分表键选择
分库分表键是指你选择进行分库分表的业务字段，有些时候会有多个字段，**根据查询来选择**

#### 重试

- 重试次数：一般来说设置无限重试是没有多大意义的。如果一个东西重试很多次都没有成功，说明大概率永远没办法重试成功了。
- 重试间隔：无非是等间隔重试或者指数退避重试。指数退避重试是指重试间隔的时间是在增长的，一般是按照两倍增长。当然面试的时候你可以设计一些更加灵活的重试间隔策略，比如说最开始按照两倍增长，再按照 50% 增长，最后保持最大重试间隔不断重试。
- 是否允许跨进程重试：如果我本身在 A 进程里面触发了重试，但是在重试了一次之后，我是否可以在 B 进程上重试第二次？在分布式环境下，这往往意味着是否可以在不同的机器上重试。

重试就是为了避开前一次失败的原因。比如说数据库因为偶发的网络抖动失败了，那么重试就是希望能够避开这次偶发性的网络抖动，再次查询成功。

#### 主键生成策略

比如说在订单 ID 里面带上了买家 ID，那么在根据订单 ID 来查询数据的时候，就可以通过解析订单 ID 来判断订单的数据在哪个库哪个表上面。

#### 引入中间表
所以查询的基本步骤也很清晰。

##### 第一个角度是结合第一个主键生成策略，优化中间表的设计。
- 先在中间表中根据卖家 ID 找到想要的订单 ID 和买家 ID。
- 再根据买家 ID 和订单号找到具体的订单数据。

> 我们用了一个比较简单的方案，就是引入了中间表来解决卖家查询的问题。这个中间表主要就是根据卖家找到对应的订单，并且根据订单表中的买家 ID 来确定目标库、目标表，再去对应的数据表里把所有的数据都查询出来。


##### 第二个角度是讨论中间表的缺陷，它最大的缺陷是性能瓶颈。

>如果中间表的数据只插入，不存在更新的话，主要就是读瓶颈，那么多加几个从库就可以了。但是如果中间表里面有一些列是需要频繁被更新的，那么中间表本身就扛不住写压力。但是本身中间表是不能分库分表的，因为分库分表之后你又面临同样的问题：你怎么知道该查询哪张中间表。

### 二次分库分表
冗余分库分表、冗余 sharding，但是指的都是这个方案。比如说，卖家也需要查询订单，那么就可以再一次按照卖家 ID 来进行分库分表。

为了减轻数据复制带来的存储压力，我们可以考虑只复制一部分表，或者某个表的一部分字段。比如在同步的时候，就不需要同步订单详情表，而是拿到订单基本信息之后再去原本的买家库里面查询订单详情。


#### 使用其他中间件支持查询

引入 Elasticsearch 也可以采用引入中间件方案中的一个优化措施，即只同步部分跟搜索相关的字段。

### 广播

如果你不能断定数据可能出现在哪一张表上，那么就直接在全部表上都查询一遍。

>如果一个查询确实没办法使用前面那些方案的时候，那就可以考虑使用广播。也就是说直接把所有的请求发送到所有的候选节点里面，然后收集到的数据就是查询的结果。不过这种方式的缺陷就是对数据库压力很大，很多数据库上的表根本不可能有数据，但是都会收到请求，白白浪费资源。尤其是如果这些查询还会触发锁，那么性能就会更差。

### 总结

1. 分库分表键的选择要注意根据候选项和业务需求来筛选，这在实践中比较容易。
2. 在设计一个重试方案时我们要考虑重试次数、重试间隔以及是否允许跨进程重试这三方面内容。
3. 此外我们还讨论了引入中间表、二次分库分表、使用其他中间件三个基础方案。并且讨论了主键生成策略对查询的影响，以及对中间表、二次分库分表两个方案的影响。
4. 广播则是兜底方案，也就是说如果你什么都不做，那么解决非分库分表键查询就可以依赖广播，但是它的性能问题也是非常突出的。


# 地址

此文章为7月day29 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/678315》