---
dg-publish: true
title: 分库分表分页查询
createTime: 2023-07-24 23:30  
---

# 分库分表分页查询

### 分库分表的一般做法

1. 哈希分库分表：根据分库分表键算出一个哈希值，然后根据这个哈希值选择一个数据库。最常见的就是使用数字类型的字段作为分库分表键，然后取余。比如说在订单表里面，按照买家的 ID 除以 8 的余数进行分表。
2. 范围分库分表：将某个数据按照范围大小进行分段。比如说根据 ID，\[0, 1000) 在一张表，\[1000, 2000) 在另外一张表上。最常见的应该是按照日期进行分库分表，比如说按照月分表，每个月一张表。
3. 中间表：引入一个中间表来记录数据所在的目标表。一般是记录主键到目标表的映射关系。

这三者并不是互斥的，也就是说你可以考虑使用哈希分库分表，同时引入一个中间表。也可以先进行范围分库分表，再引入一个中间表。

### 分库分表中间件的形态

- SDK 形态：SDK 形态就是我们最熟悉的，它通过依赖的形式引入到你的代码里面。比如说 ShardingSphere 的 Java 依赖。
- Proxy 形态：独立部署的分库分表中间件，它对于所有的业务方来说，就像一个普通的数据库，业务方的查询发送过去之后，它就会执行分库分表，发起实际查询，然后把查询结果返回给业务方。ShardingSphere 也支持这种形态。
- Sidecar 形态：简单来说就是一个提供了分库分表的 Sidecar。这是一个理论上的形态，现在并没有非常成熟的产品。

分页查询在分库分表里面是一个很难处理的问题，要么查询可能有性能问题，比如说这里使用的全局查询法，要么就是要求业务折中，比如说我优化后禁用了跨页，以及要求数据平均分布的平均分页法，当然还有各方面都不错，但是实现比较复杂的二次查询法、中间表法。

### 全局查询

分库分表中间件一般采用的都是全局排序法。假如说现在我们要查询的是 LIMIT x OFFSET y。那么分库分表中间件会把查询改写为 LIMIT x+y OFFSET 0，然后把查询请求发送给所有的目标表。在拿到所有的返回值之后，在内存中排序，并且根据排序结果找出全局符合条件的目标数据。

### 平均分页

我能不能在不同的表上平均分页查询数据，得到的结果合并在一起就是分页的结果。

在一些可以接受分页结果不精确的场景下，可以考虑平均分页的做法。举个例子来说，如果查询的是 LIMIT 4 OFFSET 2，并且命中了两张目标表，那么就可以考虑在每个表上都查询 LIMIT 2 OFFSET 1。这些结果合并在一起就是 LIMIT 4 OFFSET 2 的一个近似答案。这种做法对于数据分布均匀的分库分表效果很好，偏差也不大。

#### 禁用跨页查询
1. 要求用户只能从第 0 页开始，逐页往后翻，不允许跨页
2. 拿到上一批次的极值。
至于用最大值还是用最小值，这个取决于 ORDER BY。总的原则就是升序用最大值，降序用最小值。如果 ORDER BY 里面包含了多个列，那么针对每一个列是升序还是降序，来确定使用最大值还是使用最小值。

#### 换用其他中间件
第一种思路是用 NoSQL 之类的来存储数据。比如说使用 Elasticsearch、ClickHouse。另外一种思路是使用分布式关系型数据库。这其实就相当于你把分页的难题抛给了这些数据库，性能如何就取决于你最终选择了哪个分布式关系型数据库。

### 二次查询

二次查询的基本理念是先尝试获得某个数据的全局偏移量，然后再根据这个偏移量来计算剩下数据的偏移量。这里我用一个例子来阐述它的基本原理，再抽象出一般步骤

1. 首次查询
2. 确认最小值
3. 二次查询
4. 计算最小值的全局偏移量

根据 BETWEEN 中多出来的数据量来推断全局偏移量。现在我们知道 4 在 order_tab_0 中的偏移量是 2，也就是说比 4 小的数据有 2 条。在 BETWEEN 查询里面，order_tab_1 返回的结果是 5、7、8、9、11，7 在第一次查询里面的偏移量是 2，所以 5 的偏移量是 1。也就是说，5 的前面只有一条比 4 小的数据。

#### 分表算法

1. 首先发送查询语句 LIMIT X OFFSET Y/N 到所有的表。
2. 找到所有返回结果中的最小值（升序），记为 min。
3. 执行第二次查询，关键是 BETWEEN min AND max。其中 max 是在第一次查询的数据中每个表各自的最大值。
4. 根据 min、第一次查询和第二次查询的值来确定 min 的全局偏移量。总的来说，min 在某个表里面的偏移量这样计算：如果第二次查询比第一次查询多了 K 条数据，那么偏移量就是 Y 除以 N 减去 K。然后把所有表的偏移量加在一起，得到的就是 min 的全局偏移量。
5. 根据 min 的全局偏移量，在第二次查询的结果里面向后补足到 Y，得到第一条数据的位置，再取 X 条。



# 地址

此文章为7月day24 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/677491》