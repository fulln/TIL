---
dg-publish: true
title: Kafka 为什么性能那么好
createTime: 2023-08-23 22:53  
---

# Kafka 为什么性能那么好

### Kafka 分段与索引

在 Kafka 内部，一个分区的日志是由很多个段（segment）组成的，每个段你可以理解成一个文件。同一个 topic 的文件就存放在以 topic 命名的目录下。

为了加快段文件内的查找，每一个段文件都有两个索引文件

- 段日志文件使用了偏移量来命名。假如说一个文件的名字是 N.log
- 一个是偏移量索引文件，存储着部分消息偏移量到存储位置的映射，类似于 这种二元组。这个 offset 不是全局 offset，是相对于这个文件第一条消息的偏移量。也就是说假如第一条消息的全局偏移量是 1000，那么偏移量为 1002 的消息的索引项是 <2, pos1>。
- 一个是时间索引文件，存储着时间戳到存储位置的映射，类似于 二元组。
![](https://static001.geekbang.org/resource/image/88/e8/880b85b2c0f64bdb72665b78615335e8.png?wh=1920x783)


#### 日志查询流程

1. 在日志目录下找到名字为 test_topic_1 的子目录，里面就放着这个分区的消息日志文件。
2. 在 test_topic_1 子目录下，根据文件名进行二分查找，可以确定 20000 这条消息应该放在 010031.log 这个文件里面。
3. 利用 010031.index 的内容进行二分查找，查找索引项。如果 20000 恰好有一个索引项 <20000, pos0>，那么就读取 pos0 这个位置的数据。
4. 如果 20000 没有对应的索引项，就找到比 20000 小的最接近 20000 的索引项，假如有 <19990，pos1>，那么就从 pos1 往后遍历，找到 20000 对应的数据。

**topic 加分区定目录，偏移量定文件，索引定位置。**

它能极大地提高中间件的性能。所谓的零拷贝，就是指没有 CPU 参与的拷贝。
![](https://static001.geekbang.org/resource/image/4a/15/4ac629727b0538e96aeb2ed0c281ab15.png?wh=1920x1090)
### 零拷贝

零拷贝是中间件设计的通用技术，是指完全没有 CPU 参与的读写操作。我以从磁盘读数据，然后写到网卡上为例介绍一下。首先，应用程序发起系统调用，这个系统调用会读取磁盘的数据，读到内核缓存里面。同时，磁盘到内核缓存是 DMA 拷贝。然后再从内核缓存拷贝到 NIC 缓存中，这个过程也是 DMA 拷贝。这样就完成了整个读写操作。和普通的读取磁盘再发送到网卡比起来，零拷贝少了两次 CPU 拷贝，和两次内核态与用户态的切换。

#### 步骤
1. 应用进入内核态，从磁盘里读取数据到内核缓存，也就是读缓存。这一步应用就是发了一个指令，然后是 DMA 来完成的。
2. 应用把读缓存里的数据拷贝到应用缓存里，这个时候切换回用户态。
3. 应用进入内核态，把应用缓存里的数据拷贝到内核缓存里，也就是写缓存。
4. 应用把数据从写缓存拷贝到 NIC 缓存里，这一步应用也就是发了一个指令，DMA 负责执行。

### page cache

Kafka 充分利用了 page cache。Kafka 写入的时候只是写入到了 page cache，这几乎等价于一个内存写入操作，然后依靠异步刷新把数据刷新到磁盘上。而 page cache 是可以存放很多数据的，也就是说 Kafka 本身调用了很多次写入操作之后，才会真的触发 IO 操作，提高了性能。而且，Kafka 是基于 JVM 的，那么利用 page cache 也能缓解垃圾回收的压力。大多数跟 IO 操作打交道的中间件都有类似的机制，比如说 MySQL、Redis。

### 顺序写

Kafka 在写入数据的时候就充分利用了顺序写的特性。它针对每一个分区，有一个日志文件 WAL（write-ahead log），这个日志文件是只追加的，也就是顺序写的，因此发消息的性能会很好。MySQL、Redis 和其他消息中间件也采用了类似的技术。

假如说要写入 100M 的数据，如果只有一个分区，那就是直接顺序写入 100M。但是如果有 100 个分区，每个分区写入 1M，它的性能是要差很多的。因为一个 topic 至少有一个分区，topic 多也会影响 Kafka 的性能。最好是在创建 topic 的时候就规划好分区，但是如果没规划好，还是得考虑解决。


### 批量操作的优势

批量操作在高性能中间件里面也很常见。那么批量操作的优势究竟在哪里呢？主要体现在两个方面：一个是更少的系统调用和内核态与用户态的切换，还有一个是高效利用网络带宽。

在网络传输的时候，每一次发送都有一个固定开销，比如说协议头的部分，这个开销大小和具体的协议设计有关。假如说每个请求大小是 1KB，在网络传输的时候，分 100 次传输 1KB 和 1 次传输 100KB，后者也是明显快很多的。前者需要传输 100 次协议头，而后者只需要传输 1 次协议头。

### 高性能保证

Kafka 本身使用了很多手段来保证高性能，包括零拷贝、page cache（页缓存）、顺序读写、分区分段与索引、批量处理、压缩。其中零拷贝和顺序读写最重要，是一定要能回答出来的。

### 分区过多如何解决？

如果某个 topic 分区太多了用不上，就可以考虑不用其中的一些分区。假设说我们现在有 32 个分区，但是事实上业务本身用不上那么多分区，那么就可以考虑要求发送者只将消息发送到特定的 16 个分区上。当然，能够直接创建新 topic 是最好的。

之前阿里云中间件团队测试过，在一个 topic 八个分区的情况下，超过 64 个 topic 之后，Kafka 性能就开始下降了。

###  压缩

Kafka 还启用了压缩功能。Kafka 的压缩机制很特别。正常我们会认为如果 Kafka 支持压缩，那么应该是生产者压缩，发送到 broker 之后，broker 解压缩。然后 broker 压缩，发送到消费者之后，消费者解压缩。

Kafka 是彻底地端到端，就是生产者压缩之后发送到 broker，broker 直接存储。当 broker 推送到消费者的时候，消费者解压缩。

## 总结

通过 Kafka 的分段与索引技术，我们了解到一个消息是怎么被存储的，还有消息是怎么查找的。这里还引入了一个新概念——零拷贝技术，你需要记住相比传统 IO 它独特的优势。在回答 Kafka 为什么性能这么好这个问题的时候，你要从零拷贝、page cache、顺序写、分区、分段与索引、批量处理、压缩这几个角度回答。而如果你记不住这么多内容，那么记住零拷贝、顺序写这两个也可以。
![](https://static001.geekbang.org/resource/image/5f/40/5f9f06fdae07580aab5124a704943040.png?wh=2326x1914)
# 地址

此文章为8月day23 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/689362》