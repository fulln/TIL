---
dg-publish: true
title: 消费者客户端的SDK设计
createTime: 2023-08-05 22:49  
---

# 消费者客户端的SDK设计

消费相关功能包括**消费模型、分区消费模式、消费分组（订阅）、消费确认、消费失败处理五个部分**
## 消费模型

### 1. PULL 模型

- 好处是客户端根据自身的处理速度去拉取数据，不会对客户端和服务端造成额外的风险和负载压力。
- 缺点是可能会出现大量无效返回的 Pull 调用，另外消费及时性不够，无法满足一些需要全链路低耗时的场景。

**Pull 模型都会支持批量读，即在客户端指定需要拉取多少条数据或者拉取多大的数据，然后传递给服务端**

#### 如何规避问题

1. 服务端hold住请求
> 当客户端根据策略拉取数据时，如果没有足够的数据，就先在服务端等一段时间，等有数据后一起返回给客户端。
>  
>  1. 好处是，可以尽量提高吞吐能力，不会有太多的空交互请求
>  2. 坏处是，如果长时间不给客户端回包，会导致客户端请求超时，另外当数据不够时，hold 住请求的时间太长就会提高消费延时

2.  服务端有数据通知到客户端
> 当服务端不 hold 住请求，立刻返回空数据，客户端收到空数据时则不再发起请求，会等待服务端的通知
>当服务端有数据的时候，再主动通知客户端来拉取。

在 Pull 模型中，**比较合适的方案是客户端告诉服务端：最多需要多少数据、最少需要多少数据、未达到最小数据时可以等多久三个信息**

>服务端首先判断是否有足够的数据，有的话就立即返回，否则就根据客户端设置的等待时长 hold 住请求，如果超时，无论是否有数据，都会直接给客户端返回当前的结果。

>这种策略可以解决频繁不可控的空轮询请求。即使全是空轮询，对单个消费者来说，其 TPS 也是可以预估的，即总时间 / 等待时长 = 总轮询次数。而如果需要降低消费延时，可以通过降低最小获取的数据大小和最大等待时长来提高获取的频率，从而尽量降低延时。

### Push 模型

当服务端有数据时会主动推给客户端，让数据的消费更加及时。

#### 实现思路

1. Broker 内置 Push 功能、
	1. Broker 中内置标准的 Push 的能力，由服务端向客户端主动推送数据。
		> 优点. Broker 内部可以感知到数据堆积情况，可以保证消息被及时消费
		> 缺点：当消费者很多时，内核需要主动维护很多与第三方的长连接，并且需要处理各种客户端异常，比如客户端卡住、接收慢、处理慢等情况
1. Broker 外独立实现 Push 功能的组件
> 好处是将 Push 组件独立部署，解决了 Broker 的性能和稳定性问题，也能实现 Push 的效果
> 缺点是虽然实现了 Push 的模型，但其本质还是先 Pull 再 Push，从全链路来看，还是会存在延时较高的问题，并且需要单独开发独立的 Push 组件，开发和运维成本较高。


1. 在客户端实现伪 Push 功能三种思路。
>在客户端实现伪 Push 功能是指在客户端内部维护内存队列，SDK 底层通过 Pull 模型从服务端拉取数据存储到客户端的内存队列中。

好处在于通过客户端底层的封装，从用户体验看是 Push 模型的效果，解决用户代码层面的不断轮询问题，降低了用户的使用复杂度。缺点是底层依旧是 Pull 模型，还是得通过不断轮询的方式去服务端拉取数据，就会遇到 Pull 模型遇到的问题。

Push 模型需要先分配分区和消费者的关系，客户端就需要感知分区分配、分区均衡等操作，从而在客户端就需要实现比较重的逻辑。并且当客户端和订阅的分区数较多时，容易出现需要很长的重平衡时间的情况
### Pop 模型
客户端不需要感知到分区，直接通过 Pop 模型提供的 get 接口去获取到数据，消费成功后 ACK 数据。

不感知服务端的数据分布情况，只需要拉到数据。这种方案的好处是简化了消费模型，同时服务端可以感知到消费的堆积情况，可以根据堆积情况返回那些分区的数据给客户端，这样也简化了消息数据的分配策略。

>它将分区分配的工作移到了服务端，在服务端完成了消费者的分区分配、进度管理，然后暴露出了新的 Pop 和 ACK 接口。客户端调用 Pop 接口去拿取数据，消费成功后调用 ACK 去确认数据。这和 HTTP 的 Request 和 Response 的使用模型一致。

## 分区消费模式的设计
消息队列的数据是在 Partition/Queue 维度承载的。所以消费过程中一个重要的工作就是消费者和分区的消费模式问题，即分区的数据能不能被多个消费者并发消费，一条数据能不能被所有消费者消费到，分区的数据能不能被顺序消费等等。

*独占消费是指一个分区在同一个时间只能被一个消费者消费。*
如果消费者数量大于分区数量，则会有消费者被空置；反之，如果分区数量大于消费者数量，一个消费者则可以同时消费多个分区

#### 优点
保证分区维度的消费是有序的
#### 缺点
当数据出现倾斜、单个消费者出现性能问题或 hang 住时，会导致有些分区堆积严重。


大部分消息队列默认支持的就是独占消费的类型，比如 Kafka、RocketMQ、Pulsar 等。

*共享消费是指单个分区的数据可以同时被多个消费者消费。*
> 这种方式的好处是，可以避免单个消费者的性能和稳定性问题导致分区的数据堆积。缺点是无法保证数据的顺序消费。这种模式一般用在对数据的有序性无要求的场景，比如日志。

*广播消费是指一条数据要能够被多个消费者消费到*

#### 实现方式

1. 内核实现广播消费的模型，指在 Broker 内核中的消息投递流程实现广播消费模式，即 Broker 投递消息时，可以将一条消息吐给不同的消费者，从而实现广播消费。
2. 使用不同的消费分组对数据进行消费，指通过创建不同的消费者组消费同一个 Topic 或分区，不同的消费分组管理自己的消费进度，消费到同一条消息，从而实现广播消费的效果。
3. 指定分区消费，是指每个消费者指定分区进行消费，在本地记录消费位点，从而实现不同消费者消费同一条数据，达到广播消费的效果。

![](https://static001.geekbang.org/resource/image/f5/92/f59f74ff20f77192c9f6b50abc5d6c92.jpg?wh=1484x458)

**灾备消费是独占消费的升级版，在保持独占消费可以支持顺序消费的基础上，同时加入灾备的消费者。**

好处是既能保持独占顺序消费，又能保证容灾能力。缺点是无法解决消费倾斜的性能问题，另外还需要准备一个消费者来做灾备，使用成本较高。

# 地址

此文章为8月day5 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/673672》