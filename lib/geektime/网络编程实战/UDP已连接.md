---
dg-publish: true
---

#极客时间 #UDP 

# 14丨UDP也可以是“已连接”？

客户端在 UDP 套接字上调用 connect 函数，之后将标准输入的字符串发送到服务器端，并从服务器端接收处理后的报文。当然，向服务器端发送和接收报文是通过调用函数 sendto 和 recvfrom 来完成的

### 实施步骤

1. 创建了一个 UDP 套接字；
2. 创建了一个 IPv4 地址，绑定到指定端口和 IP；
3. 调用 connect 将 UDP 套接字和 IPv4 地址进行了“绑定”，这里 connect 函数的名称有点让人误解，其实可能更好的选择是叫做 setpeername；
4. 读取标准输入字符串后，调用 sendto 发送给对端；
5. 之后调用 recvfrom 等待对端的响应，并把对端响应信息打印到标准输出。


### UDP connect的作用

UDP connect 函数的调用，并不会引起和服务器目标端的网络交互，也就是说，并不会触发所谓的“握手”报文发送和应答。

**主要是为了让应用程序能够接收“异步错误”的信息**

在服务器端不开启的情况下，客户端程序是不会报错的，程序只会阻塞在 recvfrom 上，等待返回（或者超时）。

#### 步骤

1. 当我们调用 sendto 或者 send 操作函数时，应用程序报文被发送，我们的应用程序返回，操作系统内核接管了该报文，之后操作系统开始尝试往对应的地址和端口发送，因为对应的地址和端口不可达，一个 ICMP 报文会返回给操作系统内核，该 ICMP 报文含有目的地址和端口等信息。

2. 如果我们不进行 connect 操作，建立（UDP 套接字——目的地址 + 端口）之间的映射关系，操作系统内核就没有办法把 ICMP 不可达的信息和 UDP 套接字进行关联，也就没有办法将 ICMP 信息通知给应用程序。

3. 如果我们进行了 connect 操作，帮助操作系统内核从容建立了（UDP 套接字——目的地址 + 端口）之间的映射关系，当收到一个 ICMP 不可达报文时，操作系统内核可以从映射表中找出是哪个 UDP 套接字拥有该目的地址和端口，别忘了套接字在操作系统内部是全局唯一的，当我们在该套接字上再次调用 recvfrom 或 recv 方法时，就可以收到操作系统内核返回的“Connection Refused”的信息。

### 收发函数

使用 send 或 write 函数来发送，如果使用 sendto 需要把相关的 to 地址信息置零；

使用 recv 或 read 函数来接收，如果使用 recvfrom 需要把对应的 from 地址信息置零。

### 性能考虑

客户端通过 connect 绑定服务端的地址和端口，对 UDP 而言，可以有一定程度的性能提升。

因为如果不使用 connect 方式，每次发送报文都会需要这样的过程：连接套接字→发送报文→断开套接字→连接套接字→发送报文→断开套接字 →………而如果使用 connect 方式，就会变成下面这样：连接套接字→发送报文→发送报文→……→最后断开套接字我们知道，连接套接字是需要一定开销的，比如需要查找路由表信息。所以，UDP 客户端程序通过 connect 可以获得一定的性能提升。

## 地址

此文章为3月day15 学习笔记，内容来源于极客时间《[14丨UDP也可以是“已连接”？ (geekbang.org)](https://time.geekbang.org/column/article/129807)》，推荐该课程
