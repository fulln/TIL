#极客时间 #tcp 

# 20 | 大名⿍⿍的select：看我如何同时感知多个I/O事件

### 什么是 I/O 多路复用

使用 fgets 方法等待标准输入，但是一旦这样做，就没有办法在套接字有数据的时候读出数据；我们也可以使用 read 方法等待套接字有数据返回，但是这样做，也没有办法在标准输入有数据的情况下，读入数据并发送给对方。

使用 select 函数，通知内核挂起进程，当一个或多个 I/O 事件发生后，控制权返还给应用程序，由应用程序进行 I/O 事件的处理。

### select 函数的使用方法

```c

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);

返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

maxfd 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。比如现在的 select 待测试的描述符集合是{0,1,4}，那么 maxfd 就是 5，为啥是 5，而不是 4 呢? 我会在下面进行解释。

紧接着的是三个描述符集合，分别是读描述符集合 readset、写描述符集合 writeset 和异常描述符集合 exceptset，这三个分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生。

### 套接字描述符就绪条件

第一种情况是套接字接收缓冲区有数据可以读，如果我们使用 read 函数去执行读操作，肯定不会被阻塞，而是会直接读到这部分数据。

第二种情况是对方发送了 FIN，使用 read 函数执行读操作，不会被阻塞，直接返回 0。

第三种情况是针对一个监听套接字而言的，有已经完成的连接建立，此时使用 accept 函数去执行不会阻塞，直接返回已经完成的连接

第四种情况是套接字有错误待处理，使用 read 函数去执行读操作，不阻塞，且返回 -1

**select 检测套接字可写，完全是基于套接字本身的特性来说的**，具体来说有以下几种情况

1. 第一种是套接字发送缓冲区足够大，如果我们使用阻塞套接字进行 write 操作，将不会被阻塞，直接返回。
2. 第二种是连接的写半边已经关闭，如果继续进行写操作将会产生 SIGPIPE 信号。
3. 第三种是套接字上有错误待处理，使用 write 函数去执行写操作，不阻塞，且返回 -1。

## 地址

此文章为3月day21学习笔记，内容来源于极客时间《[20 | 大名⿍⿍的select：看我如何同时感知多个I/O事件 (geekbang.org)](https://time.geekbang.org/column/article/138948)》，推荐该课程
