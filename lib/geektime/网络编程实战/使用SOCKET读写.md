#java #tcp #极客时间 


##  05 | 使用套接字进行读写：开始交流吧

### 发送数据

```c
ssize_t write (int socketfd, const void *buffer, size_t size)
ssize_t send (int socketfd, const void *buffer, size_t size, int flags)
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
```

1. 第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。
2. 如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。
3. 如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。

#### 区别
对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流

对于socket而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的。

### 发送缓冲区

当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。

发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。

对于 send 来说，返回成功仅仅表示数据写到发送缓冲区成功，并不表示对端已经成功收到。

#### 遇到的情况

	1. 缓冲区足够大 -> 正常返回，数据就是应用程序数据大小
	2. 缓冲区不大/数据未发完 -> 程序被阻塞，不直接返回，也就是挂起，一般系统会等到数据完全放到系统发送缓冲区才返回

### 读取数据

在 UNIX 的世界里万物都是文件，这就意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。这些函数包括 read 和 write 交换数据的函数

```c
ssize_t read (int socketfd, void *buffer, size_t size)
```

read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目

#### 特殊情况

1. 返回结果为0
返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况
2. 返回值为 -1，表示出错
>  非阻塞io情况会不一样


对于 read 来说，需要循环读取数据，并且需要考虑 EOF 等异常条件。


## 地址

此文章为3月day7 学习笔记，内容来源于极客时间《[04 | TCP三次握手：怎么使用套接字格式建立连接？ (geekbang.org)](https://time.geekbang.org/column/article/116042)》，推荐该课程