#极客时间 #tcp 

# 16 | 如何理解TCP的“流”？

## TCP 是一种流式协议

在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中，至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件

接收端缓冲区保留了没有被取走的数据，随着应用程序不断从接收端缓冲区读出数据，接收端缓冲区就可以容纳更多新的数据。如果我们使用 recv 从接收端缓冲区读取数据，发送端缓冲区的数据是以字节流的方式存在的

关于**接收端字节流**，有两点需要注意

1. 先调用 send 函数发送的字节，总在后调用 send 函数发送字节的前面，这个是由 TCP 严格保证的
2. 如果发送过程中有 TCP 分组丢失，但是其后续分组陆续到达，那么 TCP 协议栈会缓存后续分组，直到前面丢失的分组到达，最终，形成可以被应用程序读取的数据流

## 网络字节排序

如果需要传输数字，比如 0x0201，对应的二进制为 0000001000000001，那么两个字节的数据到底是先传 0x01，还是相反？

不同的系统就会有两种存法，一种是将 0x02 高字节存放在起始地址，这个叫做**大端字节序**（Big-Endian）。另一种相反，将 0x01 低字节存放在起始地址，这个叫做**小端字节序**（Little-Endian）。

**我们可以看到网络协议使用的是大端字节序**


## 报文读取和解析
常见的报文格式有两种方法，
1. 一种是发送端把要发送的报文长度预先通过报文告知给接收端；
2. 另一种是通过一些特殊的字符来进行边界的划分。

## 显式编码报文长度

### 发送报文


![](attachment/Pasted%20image%2020230317231719.png)

### 解析报文：readn 函数

readn 函数中使用 count 来表示还需要读取的字符数，如果 count 一直大于 0，说明还没有满足预设的字符大小，循环就会继续

### 解析报文: read_message 函数

1. 通过调用 readn 函数获取 4 个字节的消息长度数据，
2. 通过调用 readn 函数获取 4 个字节的消息类型数据。
3. 判断消息的长度是不是太大，如果大到本地缓冲区不能容纳，则直接返回错误；
4. 调用 readn 一次性读取已知长度的消息体。

### 特殊字符作为边界

![](attachment/Pasted%20image%2020230317232029.png)

TCP 数据流特性决定了字节流本身是没有边界的，一般我们通过显式编码报文长度的方式，以及选取特殊字符区分报文边界的方式来进行报文格式的设计。而对报文解析的工作就是要在知道报文格式的情况下，有效地对报文信息进行还原

## 地址

此文章为3月day17 学习笔记，内容来源于极客时间《[16 | 如何理解TCP的“流”？ (geekbang.org)](https://time.geekbang.org/column/article/132443)》，推荐该课程