---
dg-publish: true
---
## 类加载器

把类加载阶段中的`通过一个类的全限定名来获取描述此类的二进制字节流`这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的 类。实现这个动作的代码模块称为类加载器。

### 职责

负责动态加载Java类到Java虚拟机的内存空间中,任意一个类,**必须由加载它的类加载器和它本身一起确立在jvm中的唯一性**,每一个类加载器都有独立的类名称空间,比较2个类相等只有在这个2个类都是同一个类加载器加载下才有意义

### 双亲委派模型

jvm角度看 只存在2种不同的加载器
- 启动类加载器(_这个是由c++实现的_)
- 其他类的类加载器(_全在虚拟机之外,并继承ClassLoader_)

3层类加载器
- 启动类加载器(BootstrapClassLoader)
- 扩展类加载器(Extension Class Loader)
- 应用程序类加载器(Application Class Loader) _加载用户类路径上的所有类库,是默认的类加载器_

双亲委派模型要求除了顶层的启动类加载器,其他类加载器,都应该有自己的父类加载器( 这里的父子关系不是以继承实现,而是用组合关系复用父加载器的代码)

#### 双亲委派下的加载流程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

#### 双亲委派带来的好处

1. Java类随着它的类加载器一起具备了一种带有优先级的层次关系。
2. 对于保证Java程序的稳定运作很重要

#### 破坏双亲委派模型

1. 有基础类型又要调用回子类的代码.
	1. JDNI代码由启动类加载,但是需要调用其他厂商实现并部署的SPI代码
	2. 通过线程上下文加载器去加载SPI代码，打破了双亲委派
2. 通过类加载器实现热部署,OSGI使用更复杂的网状结构加载
	1. JDK修改旧代码时,新增loadClass（已经不推荐使用而是使用findClass）的接口

## 模块化系统（JDK9）中对加载的改进

### 模块化加载的异同
1. 保留了3层类加载器和双亲委派机制,但是将扩展类加载器替换成了平台类加载器(PlatformClassloader)
2. 平台类加载器和应用程序类加载器都不在派生自URLClassloader,jdk9之后 .如果由程序依赖这种关系会导致程序崩溃

### 模块化加载的过程
		在委派给父类加载器之前,先判断该类是否归属到某个模块中,如果可以,优先委派给那个模块的加载器进行加载
