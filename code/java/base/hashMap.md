---
dg-publish: true
title: hashmap
createTime: 2024-03-03 18:15
tags:
  - java
  - javabasic
  - datastruct
  - hashmap
---
##  数据结构(链表+红黑树)
  - AbstractMap
	-  提供基础的方法,`put,get,remove,size`
  - node(继承自entity)
	- 单向链表结构
	- `k,v,hash,nextNode`
	-  红黑树(TreeNode)
		- [[code/java/base/Map中为啥使用红黑树而不使用平衡二叉树|Map中为啥使用红黑树而不使用平衡二叉树]]
  - 重写了equals 和hashcode方法
	- 重写equals以便通过k,v的值都相等时候直接相等
  - 防止hash碰撞
	- 链地址法(1.8中采用链表+红黑树
	- 结果多次hash,直到不发生碰撞
	- 开发地址法,在生成的hash值+1后再继续hash知道不发生碰撞
  - hashMap 定位element
	- hash值
	- 高位运算
		 - 将当前hash值 xor hash除以2^16 得出的结果
	- (长度-1)与index取模运算
  - entry(k,v)
	- iterator
		 - 1.8stream中的用法
  - 默认负载因子0.75
	- 关于时间上和空间上的考量,要是为1的时候,空间上占用较多,但是碰撞发生的机率变小,为0.5的时候,碰撞的几率变大,需要耗时较长的时间进行计算处理,但是内存占用上来说较小. 于是选择了这个0.75
  - 默认容量大小16
	- 容量需要满足2^n以方便扩容.所以默认初始值为16较好
- 主要方法
    - put
		1.  判断当前Node数组是不是为空，是的化，需要马上进行一次扩容
		2. 它会计算键的哈希值，并使用这个哈希值来确定键值对在内部数组（也被称为buckets）中的位置。
		3. 如果这个位置上没有任何元素，那么它会在这个位置创建一个新的节点来存储键值对。
		4. 如果这个位置上已经有元素了（这种情况被称为哈希冲突），那么它会检查这个位置上的元素是否和新插入的键相等。如果相等，那么它会更新这个键对应的值。
		5. 如果不相等,然后判断当前的node是不是属于treeNode，如果是的话，需要通过树节点的方式添加值
		6. 在添加新节点的过程中，如果链表的长度超过了一定的阈值（默认为8），那么这个链表会被转化为红黑树，以提高后续的查找效率。
		7. 然后修改次数+1，size+1
		8. 最后，如果在添加新节点后，HashMap的大小超过了阈值（容量乘以加载因子），那么HashMap会进行扩容操作，即创建一个新的内部数组，大小是原数组的两倍，并将原数组的所有元素重新放入新数组。
	  - resize
		- 以2^n次方扩容
			 - 为了在定位的时候,直接使用位预算取代取模运算
			 - 为了在扩容的时候可以快速根据当前Node的hash值来判断节点是在当前位置还是在扩容后的位置
		- 1.8中的resize和1.7中的resize相比
			 - 1.8将原始位置和新位置都设置了head和tail,插入的时候是先插入到tail中
			 - 1.7中可能会造成死锁的情况(多线程操作下,会有可能将链表头尾相接)
			 - 1.7中没有设置head和tail
		- 扩容条件
			 - 当前size达到`thesholds`阈值(容量*负载因子)
- 对key的要求
	- 如果是自定义对象，必须重写hashcode和equals方法

## 源码解析

[[code/java/base/HashMap源码解析|HashMap源码解析]]

## 相关文档

- [[lib/geektime/数据结构与算法/散列表|散列表]]
- [[lib/geektime/数据结构与算法/散列表（中）|散列表（中）]]
- [[lib/geektime/数据结构与算法/散列表（下）|散列表（下）]]