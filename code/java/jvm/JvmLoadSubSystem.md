---
dg-publish: true
---
#java #jvm #javabasic 


## 加载过程

### 类的生命周期

**加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）**

7个阶段

### Class加载过程概括

1. [[#加载(loading)]]选择类加载器根据字节流创建对应类的过程
2. [[#链接]].将创建成的类合并至 Java 虚拟机中，使之能够执行的过程
3. [[#初始化]]. 在声明时直接赋值，也可以在静态代码块中对其赋值。只有当初始化完成之后，类才正式成为可执行的状态。 

> [!tips] 类的加载过程 必须按照这种顺序按部就班地开始。而解析阶段则不一定
> 它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里笔者写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。

### 加载(loading)

#### 加载流程

1. 通过类的全限定名称获取类的2进制流(_这个步骤是放在jvm之外执行_)

>[!abstract] 主要来源有:	 
>1.从zip包中获取
>2.运行时生成(动态代理)
>3.网络中获取
>4.其他文件生成
>...

2. 将字节流代表的静态存储结构放到方法区中
3. 内存中生成一个class对象,作为这个类的访问入口

#### 加载相关点

- 对于非数组加载,用户可以自定义加载器进行类加载(权限很大)
- 数组加载的是jvm直接再内存中创建的
	1.数组的组件类型如果是引用类型的话还是需要用加载器加载
	2.如果不是引用类型的话,会把数组标为与引导类加载器关联
	3.可达性与组件类型保持一致,非引用类型都是public

### 链接

#### 验证(Verification)

验证是确保class中的信息符合jvm规范,不会危害到jvm,在jvm中验证工作占比相当大

> [!Info] 验证的阶段

1. 文件格式验证,看是否符合class结构
2. 元数据验证,是否有父类,是否不规则的重载等
3. 字节码验证,判断字节码是否正常跳转,_JDK6之后用stackMaptable属性表用**类型检查**代替**类型推断**从而节约很多时间_
4. 符号引用验证,是否能通过全限定名找到对应类

验证阶段是很重要但不是必须执行的阶段,可以通过设置`-Xverify:none` 跳过验证,缩短启动时间

#### 准备(Preparation)

该阶段就是为类中定义的变量(静态变量)分配内存,并设置初始值,**注意这里的初始值通常指数据类型的0值,不过如果该字段是常量字段,则会被初始化为指定的值**

#### 解析(Resolution)

> [!info]
解析就是将常量池内的符号引用代替为直接引用的过程

> [!warning]- 除去 invokedynamic之外.可以对第一次解析的结果进行缓存
> + 避免了重复解析的过程
> + 无论解析多少次,都需要保证在同一个实体类中,一个符号引用已经被解析成功,后续的所有次解析都能成功.保持连续性,哪怕这个请求的符号已经正确加载到了虚拟机内存
> + invokedynamic指令的目的本来就是用于动态语言支持，指必须等到程序运行到当前指令的时候解析动作才能进行

##### 针对符号类型引用进行解析

1. 类
2. 接口
3. 方法类型
4. 字段
> [!tldr] 解析字段所属的类,并返回这个类or接口。
> 1. 本身就包含了字段,直接返回字段引用
> 2. 如果实现了接口,会去接口中从下往上搜索接口和它的父类找这字段
> 3. 如果不是Object,会按照继承关系从父类找对应字段，实际上,接口和父类都有这个字段定义就会拒绝编译
> 4. 找不到就抛出异常
5. 方法
	1. 如果类方法的引用类型从常量表找出来是个接口的方法,就报异常
	2. 方法解析的其他过程和类差不多
	3. 会将该类的方法表也初始化完毕
6. 接口方法
	- 接口可以在多个父类中查找对应的简单名称方法
7. 方法句柄
8. 调用限定符

#### 初始化
[[code/java/jvm/class加载流程之初始化]]

## 加载时机

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。


## 加载器 [[code/java/jvm/classLoader]]


