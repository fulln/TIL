---
createTime: 2024-03-15 18:04
tags:
  - mysql
  - 索引
  - innodb
  - hashTable
---
## 基本概念

索引在数据库中起到比较关键的作用,涉及到**存储,事务,搜索,更新**等一系列的影响
### 聚簇索引和非聚簇索引
- 非聚簇索引(mysialm)
	- 主键索引和辅助索引的叶子节点都是数据文件的地址指针。
- 聚簇索引(Innodb)
	- 规则
		1. 主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值
		2. 根据主键查询的时候，不用回行（数据就在主键节点下
		3. 数据文件是和（主键）索引绑在一起的，即索引 + 数据 = 整个表数据文件，通过主键索引到整个记录，必须要有主键，通过主键索引效率很高
		4. 如果遇到不规则数据插入，会导致频繁页分裂
		5.  在创建辅助索引的b+树的时候可能会在目录树上加一个主键作为唯一区分
	- 优缺点
		1. 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
		2. 聚簇索引对于主键的排序查找和范围查找速度非常快
		3. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
		4. 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
		5. 辅助索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
## 常见索引结构
1. hash表
	  - 冲突后使用链表处理
	  - 优缺点
		  1. 新增很快
		  2. hash索引只能满足 <= > 和 = 查询，不能用范围查询
		  3. hash索引适合精确查询,不能利用部分索引键查询。
		  4. hash索引不支持text or json格式.
		  5. hash索引避免不了表扫描
		  6. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
 2.  有序数组
	  - 优缺点
		- 查询都很快
		- 更新数据成本高
	  - 只适用静态存储引擎
 3. 搜索树
	  - N叉搜索树
		- 根据数据块大小来决定其高度,整数型默认是1200
			 - MySql默认一个节点的长度为16K，一个整数（bigint）字段索引的长度为 8B,另外每个索引还跟着6B的指向其子树的指针；所以16K/14B ≈ 1170
			 - 第二层大概 1200页，所以 1200 * 16KB = 20M，内存还是放得下的。第三层大概144W页，要144w * 16kB =23G, 都放内存就不合适了。
		- b+树和b树的区别
			-  b+树叶子节点上的数据都是由一条双向链表连接，可以按照key排序次序遍历记录
			- 非叶子节点仅具有索引作用，跟记录有关的信息均存放在叶子节点中。
	  - 优缺点
		  - 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。
		  - 数据存放的更加紧密，具有更好的空间局部性。
		  - 因此访问叶子节点上关联的数据也具有更好的缓存命中率。
		  - B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。
		  - 而且由于数据顺序排列并且相连，所以便于区间查找和搜索。
		  - 而B树则需要进行每一层的递归遍历，**相邻的元素可能在内存中不相邻**，所以缓存命中性没有B+树好。
		  - 读写性能优异
			 - 读写空间复杂度为O(nlogn)
		 - 适配磁盘的访问模式
4.  跳表
	- redis
5. [[code/tech/LSM树详解|LSM树详解]]
	- kv引擎数据库

## 存储引擎

### memory

纯内存存储引擎,重启后丢失.
### mysialm
1. 使用b+树做为索引结构
2. 和INNODB 区别
	1. 更快的读取速度：MyISAM在执行大量的SELECT操作时通常比InnoDB更快。
	2. 不支持事务
	3. 更简单的备份和恢复：由于MyISAM表是以文件形式存储的，因此备份和恢复更加简单。
	4. MyISAM使用表级锁定，这意味着在进行写操作时会锁定整个表，可能导致并发性能问题。
3. 为啥比innoDB快
	1. mysialm只存储索引块，innoDb存储行
	2. innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快
	3. INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护MVCC (Multi-Version Concurrency Control)多版本并发控制
### INNODB 
#### 物理结构
1. 页格式
	1. 格式规则
	    - 默认16kb（16384字节
	    - 数据类型格式
			 -  Page Director（页目录
				 - 根据主键去构建对应的分组目录然后采用2分法去进行数据的查询
	        - user Record
	        - free space
		        - 上面2个空间是用来存储实际数据和估计剩余页空间的
	2. 存储规则
		1. 使用k-v的格式进行快速的定位页码信息
		2. 在mysql中， 在初次创建的时候，会建空白页作为第一页，在第二页的数据插入的时候，会将第一页的数据复制一页出来，然后新开空白页为第二页，将之前旧的第一页作为目录页使用
		3. 这样的目的是可以将第一次创建的页面缓存起来，从而提高查询的速度
2. 行格式
    - 格式规则
        - 单行数据最大大小为65532
        - 变长字段长度列表
            - 记录当前行的可变的字段的实际大小: 2个字节 即 2^16-> 65535
        - null字段标志位: 1个字节
        - 记录的头信息
        - 真实数据
            - row_id(如果已经有建立主键索引或唯一键索引的话 这个值不会被默认建立
            - transaction_id 事务id
            - roll_pointer 回滚指针
            - 其他存储字段
    - 格式类型
        - Dynamic行格式（默认行格式
        - Compressd行格式
        - compact格式
        - Reduntant行格式
	- 格式类型的区别：
		2者在对于行溢出部分处理的方式是不一样的，上面2种格式类似于compact格式,但是区别在于上面2种格式是不会存储部分数据的(简单来说当前页写不下的时候,是新开一页进行存储)，而是吧所有的数据都存储到其他的页中，在记录真实数据的部分存储其他页面的地址，另外compressed行格式还会采用页压缩的算法
    - 单行数不建议过大， 如果过大的话会导致单页面存储的空间较小，从而导致需要筛选的页数较多，从而增加树的高度
#### 概念
 1. 每一个索引都对应一个b+树
	 - 能很好配合磁盘读写,减少单次查询对磁盘的读写
 2. 支持事务
	 1. 通过transaction_id 事务id,roll_pointer 回滚指针 控制其版本链
		 1. 常见事务类型:
			-  读未提交,直接读最新的数据
			- 读已提交
			- 可重复读
			- 序列化读,使用加锁的方式去读取内容
		2. 针对读已提交和可重复读,innodb采用了readview,这里不展开讲太多:
			1.  m_ids
			    - 保存在读的时候，活跃的事务id
		        - 读已提交级别下，每次查询都要排除获取到最新的readview下的m_ids，获取到的最近的数据就是读已提交下的能展示的数据
		        - 在可重复读级别下，只会在事务第一次读的时候生成read_view，然后再去排除m_ids
			2. min_trx_id
			3. max_trx_id
			4. creater_trx_id
3. 索引的维护
    - 插入数据时
        - 页分裂
            - id不连续时,插入可能逻辑上挪动后面的数据
                - 当前页满时,会申请一个新的数据页
                - 影响数据页的使用率
            - 使用自增主键
                - 每次新增一条记录都是追加,不涉及到挪动其他记录,就不会触发页分裂
                - 主键长度越小,普通索引的叶子结点越小,占用空间就越小
    - 删除数据时
        - 页合并
 4. 普通索引与唯一索引区别
	  - 查询效率
		- 唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
		- 普通索引查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录
		- InnoDB 的数据是按数据页为单位来读写的
	  - 更新效率
		- changeBuffer
			 - 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作
			 - 虽然名字叫作 changeBuffer，实际上它是可以持久化的数据。也就是说，changeBuffer 在内存中有拷贝，也会被写入到磁盘上。
				  - merge: 除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作
			 - 什么条件下使用
				  - 唯一索引
					- 所有更新都要判断是否违反唯一性约束.所以要当前读,无法使用changebuffer
					- 需要磁盘IO读取不在内存中的数据
				  - 普通索引
					- 可以使用change buffer
					- 适用写多读少的场景
			 - 是使用的buffer pool中的内存
				  - innodb_change_buffer_max_size
			 - 与redo log区别
				  - redo log 主要节省在随机写io时的消耗
				  - change buffer 主要节省在随机读io时的消耗
5. 索引区分度
	1. 概念
	    - 一个索引上不同的值越多，这个索引的区分度就越好
	    - 一个索引上不同的值的个数，我们称之为“基数”（cardinality）
    2. 获取方式
        - 采样统计
            - InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
            - 变更的数据行数超过1/M的时候,会自动触发一次采样统计
            - 储存方式
                - innodb_stats_persistent
                    - on
                        - 持久化统计 n=20 m=10
                    - off
                        - 内存统计 n=8 m=16
        - 修正方式
            - analyze table
#### 索引优化
- 条数限制: 不是说越多越好, 索引过多会导致当前进行增删改操作的时候会消耗比较大
- 长度限制: 索引长度不能过长,InnoDb引擎下索引长度不能超过767byte
-  = 和 in 可以乱序(=中包含了范围索引后这个规则将无效,也就是说当使用了时间字段做索引的时候,最好时间字段放在最后
- 覆盖索引
	- 查询的值已经在叶子节点上,这时候不需要回表操作
	- 索引冗余
- 最左前缀原则
	- 联合索引的最左 N 个字段
	- 字符串索引的最左 M 个字符
- 联合索引构建原则
	- 复用
		 - 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的
	- 空间
	- 考虑索引下推
		 - 在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
- 索引选择异常与处理
	- 使用force index 强行选择一个索引
	- 考虑修改语句, 引导mysql 使用期望引擎
		 - 比如加入多个排序字段
		 - 根据数据特征诱导下优化器
		 - 新建更合适索引或者删除不用索引
- 在建立索引时关注的是区分度，区分度越高越好。
	- 倒序索引和hash索引不支持范围查询
	- 前缀索引和覆盖索引
		 - 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本
		 - 使用前缀索引就用不上覆盖索引对查询性能的优化了
- 不走索引的几个场景		
	- 条件字段函数操作: 对字段进行条件函数不会走索引
	- 隐式类型转换:  在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。
	- 隐式字符编码转换:  utf8 ->UTF8mb4,相当于用了CONVERT()函数