---
createTime: 2024-04-14 15:17
tags:
  - mysql
  - 锁
  - 并发
---
## 逻辑化概念

### 读锁
读锁也叫s锁，共享锁

> [!tip]
> select... lock for share mode
### 写锁
写锁也叫x锁，排他锁

> [!tip]
> - select...for update
> - delete
> - update
> - insert, insert（本质上是先加入了一个隐式的锁保证该记录不被其他记录看见
## 结构化概念

Mysql 提供以下几种锁的概念，（**无论你使用的是哪种存储引擎（例如InnoDB、MyISAM等），下列的锁都是有效的。**）：
1. **表锁（Table Locks）**：表锁是一种粗粒度的锁，它会锁定整个表。当一个事务需要对一个表进行大量的插入、更新、删除操作时，InnoDB可能会选择给这个表加上表锁，阻止其他事务对这个表进行操作。表锁可以是共享锁或者排他锁。
	- 虽然InnoDB支持表锁，但是它通常会优先使用行锁，因为行锁可以提供更高的并发性。只有在某些特殊情况下，InnoDB才会使用表锁。例如，当一个事务需要扫描整个表，或者在没有合适的索引的情况下需要执行一个复杂的查询时，InnoDB可能会选择使用表锁

> [!tip]
> lock tables … read/write
	 
2. **元空间数据锁（Metadata Locks，简称MDL）** 是MySQL为了保证事务的一致性和并发控制而引入的一种锁机制。它主要用于保护表和触发器的元数据，防止在一个事务中对表的结构进行修改（例如ALTER TABLE、DROP TABLE、RENAME TABLE等操作）时，其他事务正在对该表进行读写操作。
	- 不需要显式使用,访问时自动加上,会导致查询长时间不返回
	- 保证读写的正确性
	- 对表进行增删改查操作时,加MDL读锁
	- 对表进行结构改变时,加MDL写锁
		- 在真正拷贝数据前 退化成读锁,保证online 时不阻塞增删改
	- 事务中的MDL锁,在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
	- 如何安全给热点表加字段
		- 首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁
		- alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。
			- ALTER TABLE tbl_name NOWAIT add column ...ALTER TABLE tbl_name WAIT N add column ...

MySQL的InnoDB存储引擎提供了以下几种锁的概念：
1. **行锁（Row Locks）**：行锁是最小的锁定粒度，它直接锁定数据行。当一个事务需要修改或者删除一行数据时，InnoDB会给这行数据加上行锁，阻止其他事务对这行数据进行修改或删除。行锁可以是共享锁或者排他锁。
2. **行间隙锁（Gap Locks）**：行间隙锁是锁定一个范围，但不包括记录本身。它锁定的是两个索引记录之间的间隙，或者是第一条索引记录之前的间隙，或者是最后一条索引记录之后的间隙。行间隙锁的主要目的是防止多个事务同时插入相同的值，从而保证了事务的隔离性。
	1. 间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了
	2. 间隙锁之间不互锁
3. **行范围锁（Next-Key Locks）**：行范围锁是行锁和行间隙锁的结合，它锁定的是一个索引记录以及它之前的间隙。行范围锁可以防止其他事务插入满足某个条件的记录，从而保证了事务的隔离性。
	1. 每个 next-key lock 是前开后闭区间。
4. **插入意向锁（Insert Intention Locks）**：当一个事务想要插入一条记录，但是这个位置已经被其他事务的行间隙锁锁定时，它就会请求一个插入意向锁。插入意向锁是一种特殊的行间隙锁，它表示一个事务打算在某个间隙中插入一条记录。
5. **自动增量锁（Auto-Increment Locks）**：当一个事务需要插入一条记录到一个有自动增量的列时，InnoDB会自动获取一个特殊的自动增量锁。这个锁会在事务结束时自动释放。
6. **记录锁（Record Locks）**：这是一种行锁，它锁定的是索引记录。
7. **临键锁（Predicate Locks）**：这是在可序列化隔离级别下，InnoDB用于处理范围查询的一种锁。


## 锁的最佳实践
- 2阶段锁协议
	- 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议
	- 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放
- 死锁与死锁检查
	- 在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句，来回滚。
	- 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；
	- 解决策略
		- innodb_lock_wait_timeout 等待超时时间
		- innodb_deadlock_detect 主动死锁检测
	- 解决热点更新带来的性能问题
		- 关死锁检查，不推荐
		- 控制并发度
			 - 访问相同资源的并发事务量
- 使用**GapLock**解决幻读
	- 查找过程中访问到的对象才会加锁
	- 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
	- 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
	- 唯一索引上的范围查询会访问到不满足条件的第一个值为止。
	- 锁是加在主键索引上的
### 查询锁情况的sql
- select * from information_schema.innodb_trx
	- 记录当前运行的事务
- select * from information_schema.innodb_locks        
   - 查询当前出现的锁
- select * from information_schema.innodb_lock_waits
   - 记录锁等待的对应关系

