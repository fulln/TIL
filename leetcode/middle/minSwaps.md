## 排布二进制网格的最少交换次数

给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换。

一个符合要求的网格需要满足主对角线以上的格子全部都是 0 。

请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 。

主对角线指的是从 (1, 1) 到 (n, n) 的这些格子。

 

示例 1：



输入：grid = [[0,0,1],[1,1,0],[1,0,0]]
输出：3
示例 2：



输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
输出：-1
解释：所有行都是一样的，交换相邻行无法使网格符合要求。
示例 3：



输入：grid = [[1,0,0],[1,1,0],[1,1,1]]
输出：0
 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```go
func minSwaps(grid [][]int) int {
    //能交换到第一行的肯定能放到第二行，第三行，反之则不一定。如果有两行同时满足第一行和第二行的要求，先把最靠近的换到第一行，这样至少不会比另一种策略用的步数多。
    //比如[ [1,0,1,0] , [0,1,0,0] , [0,0,0,0] , [0,0,0,1] ] 这样的矩阵第一行是不可以和第二行交换的
    //因为根据题意第一行要求第一位之后的位全为0, 第二行要求第二位之后的位全为0............
    N := len(grid)
    a := make([]int, N) //第i行最后一个1出现的位置

    for i := 0 ; i < N ; i++ {
        a[i] = -1 
        for j := 0 ; j < N ; j++ {
            if grid[i][j] == 1 {
                a[i] = j 
            }
        }
    }
    res := 0
    for i := 0 ; i < N ; i++ {
        j := i 
        for ; j < N ; j++ {
            //关键点, 通过与对角线的比较来判断每一行最后一个1出现的位置是否可以跟对应的行交换
            if a[j] <= i {
                break
            } 
        }
        if j == N {return -1}
        for ; j > i ; j-- {
            //将适合的行数换到对应的行
            a[j], a[j-1] = a[j-1], a[j]
            res++
        }
    }
    return res
}

```
