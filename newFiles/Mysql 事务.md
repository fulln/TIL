---
createTime: 2024-03-31 21:10
tags:
  - 事务
  - mysql
---
 ##  事务
	  
	  - transaction id
			
	  - 在事务开始的时候向 InnoDB 的事务系统申请,申请顺序严格递增
			
	  - 先开始的事务获取的事务ID总是小于后开启的事务ID。 只读事务的ID和非只读事务的ID是有些区别的。前者是一个很大的数，后者是一个从1自增的数值。
			
 - 基本概念
	  
	  - 原子
			
	  - 一致
			
	  - 隔离
			
			- 隔离级别
				 
				 - 读未提交 read uncommitted
					  
				 - 读已提交 read committed
					  
				 - 可重复读（repeatable read）
					  
				 - 串行化（serializable ）
					  
			- 实现
				 
				 - mvvc
					  
				 - undo log
					  
					  - 系统里没有比这个回滚日志更早的 read-view 的时候
							
					  - 不要使用长事务
							
							- 涉及到记录很难被自动清理
								 
							- 占用锁资源
								 
	  - 持久
			
 - mvcc
	  
	  - 快照读
			
			- 概念
				 
				 - 在可重复读的情况下,事务在启动时就会执行一个快照(基于数据库)
					  
				 - 虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。
					  
				 - InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。
					  
			- 只能在RR下创建一致性快照,rc下只能创建普通的事务
				 
	  - 当前读
			
			- 概念
				 
				 - 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。
					  
	  - 每行数据都有多个版本
			
			- 1.更新数据的事务才会生成对应的数据版本
				 
			- 2.版本中包含本次数据的值,row trx_id,还有一个引用(指向上一个数据版本)
				 
	  - 事务启动时,会生成当前活跃的事务id数组
			
			- 活跃就是指,启动了但是未提交的事务
				 
			- 数组最小事务id为低水位,当前最大事务id+1为高水位
				 
				 - 高低水位组成一致性视图
					  
				 - 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
					  
				 - 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
					  
 - 事务的回滚
	  
	  - 写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash
			
			- 由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚
				 
	  - binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？
			
			- 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交
				 
			- redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整
				 
				 - b. 否则，回滚事务。
					  
				 - a. 如果是，则提交事务；
					  
	  - 设计缘由
			
		- 数据与备份的一致性有关
				 
		- 采用这个策略，主库和备库的数据就保证了一致性。