---
dg-publish: true
title: 数据库锁
createTime: 2023-07-12 23:18  
---

## 锁与索引

在 MySQL 的 InnoDB 引擎里面，锁是借助索引来实现的。或者说，加锁锁住的其实是索引项，更加具体地来说，就是锁住了叶子节点。

### 释放锁时机

当一个事务内部给数据加上锁之后，只有在执行 Rollback 或者 Commit 的时候，锁才会被释放掉。

### 乐观锁与悲观锁

乐观锁和悲观锁实际上是一种逻辑概念，它们是并发控制中常用的两种锁机制。
- 乐观锁是直到要修改数据的时候，才检测数据是否已经被别人修改过。
- 悲观锁是在初始时刻就直接加锁保护好临界资源。

在使用乐观锁和悲观锁时，需要考虑数据一致性和并发性的问题。乐观锁适用于读多写少的场景，互联网中大部分应用都属于这一类。而悲观锁则适用于写多读少的场景，比如在金融领域里面对金额的操作就是以写为主。

### 行锁与表锁

InnoDB 引擎同时支持行锁和表锁。但是行锁是借助索引来实现的，也就是说，如果你的查询没有命中任何的索引，那么 InnoDB 引擎是用不了行锁的，只能使用表锁。当然，如果用的是 MySQL，类似于 MyISAM 引擎，那么只能使用表锁，因为这些引擎不支持行锁。

### 共享锁与排它锁

- 共享锁是指一个线程加锁之后，其他线程还是可以继续加同类型的锁。
- 排它锁是指一个线程加锁之后，其他线程就不能再加锁了。

### 意向锁

意向锁相当于一个信号，就是告诉别人我要加锁了，所以意向锁并不是一个真正物理意义上的锁。

意向锁和共享锁、排它锁相结合，就有了意向共享锁和意向排它锁。
- 意向共享锁即你希望获得一个共享锁。
- 意向排它锁即你希望获得一个排它锁。

使用意向锁的典型场景是在增删改查的时候，对表结构定义加一个意向共享锁，防止在查询的时候有人修改表结构。而在修改表结构的时候，则会加一个意向排它锁。这也就是修改表结构的时候会直接阻塞掉所有的增删改查语句的原因。使用意向锁能够提高数据库的并发性能，并且避免死锁问题。

### 记录锁、间隙锁和临键锁

#### 记录锁

记录锁是指锁住了特定的某一条记录的锁

**在生产环境里面遇到了未命中索引的情况，对性能影响极大。**

#### 间隙锁

间隙锁我们一般都说两边都是开的，即端点是没有被间隙锁锁住的。记录锁和记录锁是排它的，但是间隙锁和间隙锁不是排它的。

也就是说两个间隙锁之间即便重叠了，也还是可以加锁成功的。

#### 临键锁

临键锁（Next-Key Locks）是很独特的一种锁，直观上来说可以看做是一个记录锁和间隙锁的组合。也就是说临键锁不仅仅是会用记录锁锁住命中的记录，也会用间隙锁锁住记录之间的空隙。临键锁和数据库隔离级别的联系最为紧密，它可以解决在可重复读隔离级别之下的幻读问题。


- 遇事不决临键锁。你可以认为，全部都是加临键锁的，除了下面两个子句提到的例外情况。
- 右边缺省间隙锁。例如你的值只有（1，4，7）三个，但是你查询的条件是 WHERE id < 5，那么加的其实是间隙锁，因为 7 本身不在你的条件范围内。
- 等值查询记录锁。这个其实针对的是主键和唯一索引，普通索引只适用上面两条。


# 地址

此文章为7月day12 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/674789》