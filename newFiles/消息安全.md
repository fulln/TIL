---
dg-publish: true
title: 消息安全
createTime: 2023-09-09 21:28
tags:
  - kafka
---
# 安全：身份认证、资源鉴权和加密传输都是怎么实现的？

## 消息队列的安全组成部分
消息队列的系统安全由六部分组成：**网络隔离、传输安全、集群认证、资源授权、自我保护、数据加密。**

![](https://static001.geekbang.org/resource/image/4b/e0/4b04f9604ff1393efcc414604d5e92e0.jpg?wh=3228x1488)


### 网络隔离
不管是什么系统，从安全的角度来看，最完美的保护就是网络隔离。这很好理解，一个完全隔离封闭的网络，是不会存在网络安全问题的，因为别人根本无法访问它。

但是，在实际工业环境中，除非是一些特殊的银行、国企机构的私有云环境会有完整的网络隔离，大部分情况下，我们的系统是需要和外部服务进行交互的。比如外网或者其他子网的服务需要访问我们的消息队列，或者内网应用需要外网的某些服务，此时就需要进行打通，网络隔离就无法起作用了。

如果你对安全的要求不是特别高，按默认的方式使用消息队列就可以了，因为几乎所有的消息队列默认都是不开启认证鉴权的，比如 Kafka、RocketMQ、Pulsar、RabbitMQ 默认都可以直接访问的

### 数据传输过程加密

我们的应用必须访问外界服务，也必定存在公网的数据传输。为了防止数据在传输过程中不被窃取、改变，确保数据的完整性，我们需要对传输过程中的数据进行加密。

数据传输安全的核心是 **SSL/TLS**，你可以简单理解成，如果要保证传输过程中的数据安全，就要用 **SSL/TLS**。消息队列也是这个逻辑，几乎所有的消息队列产品，传输过程中的加密机制都是基于 SSL/TLS 实现的

> 简单理解，SSL 和 TLS 是同一个东西。SSL 3.0 及之前的版本叫 SSL，3.0 之后叫做 TLS，TLS 是 SSL 的升级版。

> 大部分消息队列为了保证延时和吞吐，都是基于四层的 TCP 协议构建的，所以在加密传输的实现上都是 TCP + SSL/TLS。另外在七层的加密传输中，HTTPS 是我们最熟悉的一种，它的底层机制是基于 HTTP + SSL 实现的。

### 连接建立时的身份认证

加密传输，只能解决数据在网络传输过程中的安全性，此时消息队列集群资源还处于一个门户大开的状态，只要网络能通，集群就能被直接连接访问。为了解决这个问题，就需要开启集群认证。

**集群认证，通俗解释就是消息队列中的登录功能。** 前面提到，默认情况下消息队列是不开启认证的，需要时，我们可以通过配置开启认证。认证是客户端连接服务端的第一道门槛，主要是解决客户端连接到服务端时，是否允许建立连接的问题。

##### 框架与实现

最简单的认证框架，可以是一个 Java 的接口定义。具体代码也很简单，先定义一个接口 AuthenticationProvider，接口中包含了 authenticate 方法，只要实现了这个接口的类都是认证实现类，都可以执行认证操作。

###### 身份认证框架

![](https://static001.geekbang.org/resource/image/10/99/10af4f5fb6968a731f1931c58fe23699.jpg?wh=3000x963)
1. kafka，SALA-简单身份验证和安全层，你可以把它理解为一个框架，在这个框架上扩展各种身份验证提供程序，Kafka 在开发的时候引入了 SASL，然后基于 SASL 实现各种认证插件，比如 GSSAPI、PLAIN、SCRAM、OAUTH 等等，程序上就可以顺利集成各种认证机制了。
2. RabbitMq 和Pulsar,在内核提供了一个自定义实现的、可插入的身份验证框架，基于认证接口实现各种认证机制，并在配置文件中指定要启用的认证插件和参数，然后开启认证的。

Kafka 和 Pulsar/RabbitMQ 最大的区别在于认证框架的选择。SASL 框架的机制更完善，基于 SASL 需要遵循编码规范和机制，相对复杂，同时功能也相对较强，这是可预期的。
###### 身份认证实现
最简单的认证实现就是用户名 + 密码，把用户名和密码传递给服务端进行比对。不过为了安全性和各个场景下都能方便认证，业界提供了非常多种的认证机制，比如 OAuth、Token、Kerberos、PLAINTEXT 等等。

1. 用户名 + 密码的机制
	1. Kafka 的 PLAIN、SCRAM，RabbitMQ 的 PLAIN、AMQPPLAIN，RocketMQ 的 AccessKey 和 SecretKey 都属于这类
2. Kerberos
	1. 用来在非安全网络中对个人通信进行身份认证，属于一种标准的授权协议。很多组件中都会支持它，所以在很多消息队列产品或者大数据产品的认证模块中，我们都会经常看到。
	2. 使用 Kerberos 的时候，一般需要先配置一个 Kerberos 配置中心，然后消息队列配置上配置中心的相关信息，收到客户端的验证请求的时候，通过 Kerberos 配置中心完成认证。
3. OAuth 认证
	1. 允许用户以 Token 的形式，授权第三方应用访问他们存储在另外服务提供者上的信息。
	2. JWT、原始 Token 授权、mTLS 等等，原理是类似的，区别是不同厂商推出的满足不同特定的场景下的认证机制。

###### 集群资源的访问控制
在很多场景下，比如一个公司规模不大的时候，整个公司会共用一套集群。此时如果一些部门的数据不能让其他部门看到，身份认证就不能满足需求了。

1. 数据类和资源类操作控制
	1. 消息队列的集群，应该知道集群有两类操作，一种是集群资源类的操作，比如主题和用户信息的创建删除、限流配额信息的配置。一种是数据资源类的操作，比如生产消费某个数据。
	2. 独立两条链路，比如数据操作（生产和消费）使用 TCP 链路，集群资源的操作使用 HTTP 链路。
	3. 同一条链路上实现两种操作，数据操作和集群资源操作在同一条 TCP 或 HTTP 链路上完成，然后通过接口或资源类型维度的鉴权来实现管控。

> 业务方主要访问数据链路，运维方主要访问资源链路。它的好处是资源类操作和数据类操作分开，从而在内核层面对鉴权控制实现的成本更低，编码量更少。在集群的交付和运营层面，无需额外配置访问权限，配置维护成本较低。Pulsar 和 RabbitMQ 用的就是这种方案。

> 另一种单条链路的方案，在一条链路上完成所有的操作，无需在内核中开启两个 Server。坏处就是需要额外设计多个维度（比如集群、主题、配置相关）的权限控制，内核的编码量较多，而且在集群运维时的配置成本也较高。业界的 Kafka、RocketMQ 用的就是这种方案。

###### 访问控制机制 ACL
我们在数据链路内还是会包含生产、消费两个行为，另外可能有幂等、事务等特性，在资源链路里面也会有资源的增删改查等操作。在一些情况下，我们需要对这些操作做更细粒度的控制，这时候就需要访问控制技术（ACL）登场了。

1. 从被访问主体的角度（即哪些行为和资源需要鉴权），一般分为三类。
	1. 资源：主要对主题 / Queue、消费分组 / 订阅、集群三类资源做访问控制。另外一些消息队列独有的概念也会有需要做访问控制，比如 RabbitMQ 的 Exchange。
	2. 操作：主要分为读、写、创建、删除、修改、配置等，比如允许生产消费数据、允许创建删除修改 Topic、允许修改集群配置。
	3. 接口：一般会限制对集群接口的访问，比如限制某些用户不能访问某些接口。
2. 从访问控制主体的角度（即如何实现鉴权），一般需要包含用户和 IP 两个维度。
	1. 用户维度就是指控制某个用户的访问权限。
	2. IP 维度是指这个资源只能从某个或某些 IP 发起访问。

![](https://static001.geekbang.org/resource/image/a6/15/a6d646a3291584723f52dc80a297b515.png?wh=1492x1352)

###### 那访问控制机制具体如何实现呢？
1. 请求接入的时候，获取到当前连接的用户信息或者 IP 信息。
2. 在请求处理的开始，调用访问控制的实现函数（比如 authorizeByResourceType），传入当前访问的操作（比如生产、消费、配置）以及用户或 IP 信息，和内存中的授权数据比较，返回是否具有权限。

> 在具体编码实现上，消息队列一般都会支持一个可插拔的鉴权机制，即可以通过配置自定义的鉴权类来实现自定义的鉴权。

Kafka 的鉴权配置就是可插拔的，通过配置 authorizer.class.name 的参数，来制定 ACL 的鉴权规则。它的实现就是定义接口，然后实现接口的检验函数来完成校验。

##### 超级用户

在系统中有一个默认的超级用户，是非常必要的。如果没有超级用户，一旦分配出去的用户被不小心或者恶意修改，系统就无法恢复访问了，超级用户的存在可以很好地避免这个问题。另外，在系统运维过程中，超级用户会带来很多管理上的便利，比如运维负责人的临时、紧急状态的操作。


# 地址
此文章为9月day9 学习笔记，内容来源于极客时间《https://time.geekbang.org/column/article/683363》